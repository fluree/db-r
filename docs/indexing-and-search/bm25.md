# BM25 Full-Text Search

Fluree provides integrated full-text search using the BM25 (Best Matching 25) ranking algorithm. BM25 indexes enable fast keyword search with relevance scoring.

## What is BM25?

BM25 is a probabilistic ranking function that scores documents based on query term frequency and document length normalization. It's widely used in search engines and information retrieval systems.

**Key Features:**
- Term frequency with saturation
- Inverse document frequency weighting
- Document length normalization
- Tunable parameters (k1, b)

## Creating a BM25 Index

### Basic Index

Create a BM25 index for searching:

```bash
curl -X POST "http://localhost:8090/index/bm25?ledger=mydb:main" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "products-search",
    "source": "mydb:main",
    "fields": [
      { "predicate": "schema:name" },
      { "predicate": "schema:description" }
    ]
  }'
```

This creates a search index named `products-search:main`.

### Fields with Weights

Weight important fields higher:

```json
{
  "name": "products-search",
  "source": "mydb:main",
  "fields": [
    { "predicate": "schema:name", "weight": 3.0 },
    { "predicate": "schema:description", "weight": 1.0 },
    { "predicate": "schema:tags", "weight": 2.0 }
  ]
}
```

Higher weights boost matches in those fields.

### Filtering by Type

Index only specific entity types:

```json
{
  "name": "products-search",
  "source": "mydb:main",
  "filter": {
    "@type": "schema:Product"
  },
  "fields": [
    { "predicate": "schema:name" },
    { "predicate": "schema:description" }
  ]
}
```

## Querying BM25 Indexes

### Basic Search

Search using the `bm25:matches` predicate:

```json
{
  "@context": {
    "schema": "http://schema.org/",
    "bm25": "https://ns.flur.ee/bm25#"
  },
  "from": "products-search:main",
  "select": ["?product", "?name", "?score"],
  "where": [
    { "@id": "?product", "bm25:matches": "laptop computer" },
    { "@id": "?product", "schema:name": "?name" },
    { "@id": "?product", "bm25:score": "?score" }
  ],
  "orderBy": ["-?score"],
  "limit": 20
}
```

**Results:**
```json
[
  {
    "product": "ex:product-123",
    "name": "Dell Laptop Computer",
    "score": 8.75
  },
  {
    "product": "ex:product-456",
    "name": "HP Gaming Laptop",
    "score": 7.32
  }
]
```

### SPARQL Search

```sparql
PREFIX schema: <http://schema.org/>
PREFIX bm25: <https://ns.flur.ee/bm25#>

SELECT ?product ?name ?score
FROM <products-search:main>
WHERE {
  ?product bm25:matches "laptop computer" .
  ?product schema:name ?name .
  ?product bm25:score ?score .
}
ORDER BY DESC(?score)
LIMIT 20
```

## Search Features

### Phrase Search

Search for exact phrases:

```json
{
  "@id": "?doc",
  "bm25:matches": "\"wireless headphones\""
}
```

Matches documents containing the exact phrase "wireless headphones".

### Boolean Operators

Combine terms with AND, OR, NOT:

```json
{
  "@id": "?product",
  "bm25:matches": "laptop AND (gaming OR professional) NOT budget"
}
```

### Wildcard Search

Use wildcards for partial matching:

```json
{
  "@id": "?product",
  "bm25:matches": "compute*"
}
```

Matches: computer, computers, computing, computational, etc.

### Field-Specific Search

Search specific fields:

```json
{
  "@id": "?product",
  "bm25:matches": "name:laptop description:professional"
}
```

## Relevance Scoring

### BM25 Score

The `bm25:score` predicate provides relevance scores:

```text
Score factors:
- Term frequency in document
- Inverse document frequency
- Document length normalization
- Field weights
```

Higher scores = better matches.

### Score Thresholds

Filter by minimum score:

```json
{
  "where": [
    { "@id": "?product", "bm25:matches": "laptop" },
    { "@id": "?product", "bm25:score": "?score" }
  ],
  "filter": "?score > 5.0"
}
```

## Combining with Structured Queries

Combine text search with graph queries:

```json
{
  "from": ["mydb:main", "products-search:main"],
  "select": ["?product", "?name", "?price", "?score"],
  "where": [
    { "@id": "?product", "bm25:matches": "laptop" },
    { "@id": "?product", "bm25:score": "?score" },
    { "@id": "?product", "schema:name": "?name" },
    { "@id": "?product", "schema:price": "?price" },
    { "@id": "?product", "schema:category": "ex:electronics" }
  ],
  "filter": "?price < 1000",
  "orderBy": ["-?score"]
}
```

This finds laptops under $1000 in electronics category, ranked by relevance.

## Index Configuration

### BM25 Parameters

Tune BM25 algorithm parameters:

```json
{
  "name": "products-search",
  "source": "mydb:main",
  "fields": [...],
  "parameters": {
    "k1": 1.2,
    "b": 0.75
  }
}
```

**k1** (default 1.2):
- Controls term frequency saturation
- Higher values: more weight to term frequency
- Range: 1.2 - 2.0

**b** (default 0.75):
- Controls document length normalization
- 0 = no normalization, 1 = full normalization
- Range: 0.0 - 1.0

### Stopwords

Configure stopwords to exclude:

```json
{
  "name": "products-search",
  "source": "mydb:main",
  "fields": [...],
  "stopwords": ["the", "a", "an", "and", "or", "but"]
}
```

### Stemming

Enable stemming for better recall:

```json
{
  "name": "products-search",
  "source": "mydb:main",
  "fields": [...],
  "stemming": "english"
}
```

Supported languages: english, spanish, french, german, etc.

## Index Maintenance

### Index Status

Check index status:

```bash
curl http://localhost:8090/index/bm25/products-search:main
```

Response:
```json
{
  "name": "products-search:main",
  "status": "ready",
  "documents": 10523,
  "last_updated": "2024-01-22T10:30:00Z",
  "size_bytes": 52428800,
  "source_t": 150,
  "index_t": 150,
  "lag_ms": 0
}
```

### Rebuilding Index

Rebuild from scratch:

```bash
curl -X POST http://localhost:8090/index/bm25/products-search:main/rebuild
```

### Deleting Index

Remove an index:

```bash
curl -X DELETE http://localhost:8090/index/bm25/products-search:main
```

## Real-Time Updates

BM25 indexes update automatically as data changes:

### Insert

```json
{
  "@graph": [
    {
      "@id": "ex:product-new",
      "@type": "schema:Product",
      "schema:name": "New Laptop",
      "schema:description": "Latest model"
    }
  ]
}
```

Document automatically added to index.

### Update

```json
{
  "where": [
    { "@id": "ex:product-123", "schema:description": "?oldDesc" }
  ],
  "delete": [
    { "@id": "ex:product-123", "schema:description": "?oldDesc" }
  ],
  "insert": [
    { "@id": "ex:product-123", "schema:description": "Updated description" }
  ]
}
```

Index updated automatically.

### Delete

```json
{
  "where": [
    { "@id": "ex:product-123", "?pred": "?val" }
  ],
  "delete": [
    { "@id": "ex:product-123", "?pred": "?val" }
  ]
}
```

Document removed from index.

## Performance

### Index Build Time

Initial indexing time:

```text
10,000 documents × 500 words average = ~5 million words
Index build time: ~30 seconds

100,000 documents: ~5 minutes
1,000,000 documents: ~50 minutes
```

### Query Performance

Search query times:

```text
Small index (< 10K docs): < 10ms
Medium index (< 100K docs): < 50ms
Large index (< 1M docs): < 200ms
Very large index (> 1M docs): < 500ms
```

### Index Size

Approximate index sizes:

```text
Document size: 1 KB average
Index overhead: ~2-3×
Index size: 2-3 KB per document

10,000 docs: 20-30 MB
100,000 docs: 200-300 MB
1,000,000 docs: 2-3 GB
```

## Use Cases

### E-commerce Product Search

```json
{
  "from": ["products:main", "products-search:main"],
  "select": ["?product", "?name", "?price", "?image"],
  "where": [
    { "@id": "?product", "bm25:matches": "?userQuery" },
    { "@id": "?product", "schema:name": "?name" },
    { "@id": "?product", "schema:price": "?price" },
    { "@id": "?product", "schema:image": "?image" },
    { "@id": "?product", "schema:inStock": true }
  ],
  "orderBy": ["-?score"],
  "limit": 24
}
```

### Document Management

```json
{
  "from": "documents-search:main",
  "select": ["?doc", "?title", "?author", "?date"],
  "where": [
    { "@id": "?doc", "bm25:matches": "quarterly financial report" },
    { "@id": "?doc", "schema:title": "?title" },
    { "@id": "?doc", "schema:author": "?author" },
    { "@id": "?doc", "schema:datePublished": "?date" }
  ],
  "filter": "?date >= '2024-01-01'",
  "orderBy": ["-?score"]
}
```

### Knowledge Base Search

```json
{
  "from": "articles-search:main",
  "select": ["?article", "?title", "?snippet"],
  "where": [
    { "@id": "?article", "bm25:matches": "machine learning neural networks" },
    { "@id": "?article", "schema:headline": "?title" },
    { "@id": "?article", "bm25:snippet": "?snippet" }
  ],
  "limit": 10
}
```

The `bm25:snippet` predicate provides highlighted excerpts.

## Best Practices

### 1. Weight Fields Appropriately

```json
{
  "fields": [
    { "predicate": "schema:name", "weight": 3.0 },      // Most important
    { "predicate": "schema:headline", "weight": 2.5 },
    { "predicate": "schema:description", "weight": 1.0 },
    { "predicate": "schema:keywords", "weight": 2.0 }
  ]
}
```

### 2. Filter by Type

Only index relevant entities:

```json
{
  "filter": {
    "@type": ["schema:Product", "schema:Offer"]
  }
}
```

### 3. Use Stemming

Enable stemming for better recall:

```json
{
  "stemming": "english"
}
```

### 4. Monitor Index Lag

```javascript
const status = await getIndexStatus('products-search:main');
if (status.lag_ms > 5000) {
  console.warn('Search index lag > 5 seconds');
}
```

### 5. Limit Results

Always use LIMIT:

```json
{
  "where": [...],
  "limit": 50
}
```

## Deployment Modes

BM25 indexes support two deployment modes: **embedded** (default) and **remote**. This allows you to run the search index locally for simplicity, or offload it to a dedicated search service for scalability.

### Embedded Mode (Default)

In embedded mode, the BM25 index is loaded and searched within the same process as Fluree:

```json
{
  "deployment": {
    "mode": "embedded"
  }
}
```

This is the default behavior when no deployment configuration is specified.

**Advantages:**
- No network latency
- Simpler deployment
- No additional services to manage

**Use when:**
- Index size is manageable (< 1GB)
- Single instance deployments
- Development and testing

### Remote Mode

In remote mode, search queries are delegated to a dedicated search service:

```json
{
  "deployment": {
    "mode": "remote",
    "endpoint": "http://search.example.com:9090/v1/search",
    "auth_token": "your-secret-token",
    "request_timeout_ms": 10000
  }
}
```

**Configuration options:**
- `mode`: `"remote"` to enable remote search
- `endpoint`: URL of the search service (required)
- `auth_token`: Bearer token for authentication (optional)
- `connect_timeout_ms`: Connection timeout in milliseconds (default: 5000)
- `request_timeout_ms`: Request timeout in milliseconds (default: 30000)

**Advantages:**
- Scales independently from Fluree instances
- Can handle larger indexes
- Shared search service across multiple Fluree instances

**Use when:**
- Large indexes that need dedicated resources
- Multiple Fluree instances sharing the same index
- Production deployments requiring horizontal scaling

### Running the Search Service

The `fluree-search-httpd` binary provides a standalone HTTP server for remote BM25 search:

```bash
fluree-search-httpd \
  --storage-root file:///var/fluree/data \
  --nameservice-path file:///var/fluree/ns \
  --listen 0.0.0.0:9090
```

**Server options:**
- `--storage-root`: Path to Fluree storage (where indexes are persisted)
- `--nameservice-path`: Path to nameservice data
- `--listen`: Address and port to listen on (default: `0.0.0.0:9090`)
- `--cache-max-entries`: Maximum cached indexes (default: 100)
- `--cache-ttl-secs`: Cache TTL in seconds (default: 300)
- `--max-limit`: Maximum results per query (default: 1000)

**Endpoints:**
- `POST /v1/search` - Execute a search query
- `GET /v1/capabilities` - Get server capabilities and limits
- `GET /v1/health` - Health check

### Search Service Protocol

The remote search service uses a JSON-based protocol:

**Request:**
```json
{
  "protocol_version": "1.0",
  "vg_alias": "products-search:main",
  "query": { "kind": "bm25", "text": "laptop computer" },
  "limit": 20,
  "as_of_t": 150,
  "sync": false,
  "timeout_ms": 5000
}
```

**Response:**
```json
{
  "protocol_version": "1.0",
  "index_t": 150,
  "hits": [
    { "iri": "ex:product-123", "ledger_alias": "mydb:main", "score": 8.75 }
  ],
  "took_ms": 12
}
```

### Parity Guarantee

Both embedded and remote modes use identical:
- Analyzer configuration (tokenization, stemming, stopwords)
- BM25 scoring algorithm and parameters
- Time-travel and sync semantics

This ensures queries return identical results regardless of deployment mode.

## Related Documentation

- [Background Indexing](background-indexing.md) - Core indexing
- [Vector Search](vector-search.md) - Similarity search
- [Virtual Graphs](../virtual-graphs/README.md) - Virtual graph concepts
- [Query](../query/README.md) - Query syntax
- [Search Service Protocol](../design/SEARCH_SERVICE_PROTOCOL.md) - Protocol specification
