# BM25 Graph Source

BM25 indexes in Fluree are implemented as graph sources, allowing full-text search to be seamlessly integrated with structured graph queries through the standard query interface.

## Overview

A BM25 graph source:
- Indexes text content from a source ledger using a configurable query
- Provides relevance-ranked search results via BM25 scoring
- Integrates with JSON-LD queries through `f:` namespace predicates
- Supports time-travel (query the index at any historical point)
- Maintains a manifest of snapshots for incremental sync

For index creation, configuration, and lifecycle management, see [BM25 Full-Text Search](../indexing-and-search/bm25.md).

## Querying BM25 Graph Sources

### JSON-LD Search Pattern

BM25 search uses the `f:` (Fluree) namespace predicates in where clauses:

```json
{
    "@context": {
        "ex": "http://example.org/",
        "f": "https://ns.flur.ee/db#"
    },
    "from": "docs:main",
    "where": [
        {
            "f:graphSource": "article-search:main",
            "f:searchText": "rust programming",
            "f:searchLimit": 10,
            "f:searchResult": {
                "f:resultId": "?doc",
                "f:resultScore": "?score"
            }
        },
        { "@id": "?doc", "ex:title": "?title" }
    ],
    "select": ["?doc", "?title", "?score"]
}
```

### Pattern Fields

| Field | Required | Description |
|-------|----------|-------------|
| `f:graphSource` | Yes | Graph source ID (e.g., `"article-search:main"`) |
| `f:searchText` | Yes | Query text. Analyzed with the same tokenizer/stemmer as indexing. |
| `f:searchLimit` | Yes | Maximum number of search results to return |
| `f:searchResult` | Yes | Object with variable bindings for results |
| `f:resultId` | Yes | Variable for the matched document IRI (e.g., `"?doc"`) |
| `f:resultScore` | No | Variable for the BM25 relevance score (e.g., `"?score"`) |
| `f:resultLedger` | No | Variable for the source ledger alias (for multi-ledger provenance) |

### How It Works

1. The search pattern is parsed and turned into a `Bm25SearchOperator`
2. The operator loads the BM25 index from storage (using the leaflet cache when available)
3. Query text is analyzed (tokenized, lowercased, stopwords removed, stemmed)
4. The top-k results are computed using Block-Max WAND, which skips posting list segments whose upper-bound scores cannot enter the result set, then returns the highest-scoring documents
5. Results produce variable bindings (`?doc`, `?score`) that flow into subsequent where clauses
6. Subsequent patterns join against the source ledger to retrieve additional properties

## Joining with Ledger Data

The primary use case is combining search results with structured graph data:

```json
{
    "@context": {
        "ex": "http://example.org/",
        "f": "https://ns.flur.ee/db#"
    },
    "from": "docs:main",
    "where": [
        {
            "f:graphSource": "article-search:main",
            "f:searchText": "database design",
            "f:searchLimit": 20,
            "f:searchResult": { "f:resultId": "?doc", "f:resultScore": "?score" }
        },
        { "@id": "?doc", "ex:title": "?title" },
        { "@id": "?doc", "ex:author": "?author" },
        { "@id": "?doc", "ex:year": "?year" }
    ],
    "select": ["?doc", "?title", "?author", "?year", "?score"]
}
```

The BM25 search runs first, producing a set of `(?doc, ?score)` bindings. The remaining where clauses join those bindings against the source ledger to enrich results with structured data.

## Rust API

### Creating and Querying

```rust
use fluree_db_api::{Bm25CreateConfig, FlureeBuilder};
use serde_json::json;

let fluree = FlureeBuilder::memory().build_memory();

// Seed ledger
let ledger0 = fluree.create_ledger("docs:main").await?;
let tx = json!({
    "@context": { "ex": "http://example.org/" },
    "@graph": [
        { "@id": "ex:doc1", "@type": "ex:Doc", "ex:title": "Rust guide", "ex:author": "Alice" },
        { "@id": "ex:doc2", "@type": "ex:Doc", "ex:title": "Python intro", "ex:author": "Bob" }
    ]
});
let ledger = fluree.insert(ledger0, &tx).await?.ledger;

// Create index
let query = json!({
    "@context": { "ex": "http://example.org/" },
    "where": [{ "@id": "?x", "@type": "ex:Doc", "ex:title": "?title" }],
    "select": { "?x": ["@id", "ex:title"] }
});
let config = Bm25CreateConfig::new("search", "docs:main", query);
let created = fluree.create_full_text_index(config).await?;

// Query with BM25 search + ledger join
let search_query = json!({
    "@context": { "ex": "http://example.org/", "f": "https://ns.flur.ee/db#" },
    "from": "docs:main",
    "where": [
        {
            "f:graphSource": &created.graph_source_id,
            "f:searchText": "rust",
            "f:searchLimit": 10,
            "f:searchResult": { "f:resultId": "?doc", "f:resultScore": "?score" }
        },
        { "@id": "?doc", "ex:author": "?author" }
    ],
    "select": ["?doc", "?score", "?author"]
});

let result = fluree.query_connection_with_bm25(&search_query).await?;
```

### Using FlureeIndexProvider

The `FlureeIndexProvider` implements the `Bm25IndexProvider` and `Bm25SearchProvider` traits, used by the query engine for graph source resolution:

```rust
use fluree_db_api::FlureeIndexProvider;
use fluree_db_query::bm25::{Bm25IndexProvider, Bm25Scorer, Analyzer};

let provider = FlureeIndexProvider::new(&fluree);

// Load index through the provider (with optional sync and time-travel)
let index = provider
    .bm25_index("search:main", Some(ledger.t()), false, None)
    .await?;

// Direct search
let analyzer = Analyzer::english_default();
let terms = analyzer.analyze_to_strings("rust");
let term_refs: Vec<&str> = terms.iter().map(|s| s.as_str()).collect();
let scorer = Bm25Scorer::new(&index, &term_refs);
let results = scorer.top_k(10);
```

## Remote Search Service

For large indexes or multi-instance deployments, BM25 search can be delegated to a standalone search service.

### Running the Search Service

```bash
fluree-search-httpd \
  --storage-root file:///var/fluree/data \
  --nameservice-path file:///var/fluree/ns \
  --listen 0.0.0.0:9090
```

**Server options:**
- `--storage-root`: Path to Fluree storage (where indexes are persisted)
- `--nameservice-path`: Path to nameservice data
- `--listen`: Address and port (default: `0.0.0.0:9090`)
- `--cache-max-entries`: Maximum cached indexes (default: 100)
- `--cache-ttl-secs`: Cache TTL in seconds (default: 300)
- `--max-limit`: Maximum results per query (default: 1000)

### Search Protocol

The remote search service uses a JSON-based protocol:

**Request:**
```json
{
    "protocol_version": "1.0",
    "graph_source_id": "article-search:main",
    "query": { "kind": "bm25", "text": "rust programming" },
    "limit": 20,
    "as_of_t": 150,
    "sync": false,
    "timeout_ms": 5000
}
```

**Response:**
```json
{
    "protocol_version": "1.0",
    "index_t": 150,
    "hits": [
        { "iri": "http://example.org/doc1", "ledger_id": "docs:main", "score": 8.75 },
        { "iri": "http://example.org/doc2", "ledger_id": "docs:main", "score": 7.32 }
    ],
    "took_ms": 12
}
```

**Endpoints:**
- `POST /v1/search` — Execute a search query
- `GET /v1/capabilities` — Get server capabilities and limits
- `GET /v1/health` — Health check

### Parity Guarantee

Both embedded and remote modes use identical:
- Analyzer configuration (tokenization, stemming, stopwords)
- BM25 scoring algorithm and parameters
- Time-travel and sync semantics

Queries return identical results regardless of deployment mode.

**Time-travel note**: BM25 time-travel selection is implemented by BM25 itself via a manifest/root in storage. The nameservice stores only a head pointer to the latest BM25 manifest (an opaque address) and does not store BM25 snapshot history.

## Graph Source Identity

BM25 graph sources are registered in the nameservice as `@type: "f:GraphSourceDatabase"` records:

- **ID format**: `{name}:{branch}` (e.g., `article-search:main`)
- **Name**: Cannot contain `:` (reserved for ID formatting)
- **Branch**: Defaults to `"main"`
- **Dependencies**: Tracked for the source ledger(s) the index draws from
- **Config**: Stores the indexing query and BM25 parameters (k1, b)

Query the nameservice to discover graph sources:

```bash
curl -X POST http://localhost:8090/nameservice/query \
  -H "Content-Type: application/json" \
  -d '{
    "@context": {"f": "https://ns.flur.ee/db#"},
    "select": ["?name", "?gs"],
    "where": [{"@id": "?gs", "@type": "f:GraphSourceDatabase", "f:name": "?name"}]
  }'
```

## Related Documentation

- [BM25 Full-Text Search](../indexing-and-search/bm25.md) - Index creation, configuration, maintenance, and storage internals
- [Graph Sources Overview](overview.md) - Graph source concepts
- [Query Datasets](../query/datasets.md) - Multi-graph queries
