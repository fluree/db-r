//! Novelty overlay for Fluree DB
//!
//! This crate provides in-memory storage for uncommitted transactions (novelty)
//! that overlays the persisted index. It uses sorted vectors per index for
//! cache locality and efficient merge operations.
//!
//! # Design
//!
//! - **Arena storage**: Flakes stored once in a central arena, referenced by FlakeId
//! - **Per-index sorted vectors**: Each index (SPOT, PSOT, POST, OPST) maintains
//!   a sorted vector of FlakeIds ordered by that index's comparator
//! - **Batch commit**: Epoch bumps once per commit, not per flake
//! - **LSM-style merge**: Sort batch by index comparator, then linear merge with existing
//!
//! # Example
//!
//! ```ignore
//! use fluree_db_novelty::Novelty;
//!
//! let mut novelty = Novelty::new(0);
//! novelty.apply_commit(flakes, 1, &reverse_graph)?;
//!
//! // Get slice for a specific graph's leaf range
//! let slice = novelty.slice_for_range(g_id, IndexType::Spot, Some(&first), Some(&rhs), false);
//! ```

mod commit;
mod commit_flakes;
pub mod commit_v2;
mod error;
mod stats;

pub use commit::{
    load_commit_by_id, load_commit_envelope_by_id, trace_commit_envelopes_by_id,
    trace_commits_by_id, Commit, CommitEnvelope, CommitRef, TxnMetaEntry, TxnMetaValue,
    TxnSignature, MAX_TXN_META_BYTES, MAX_TXN_META_ENTRIES,
};
pub use commit_flakes::generate_commit_flakes;
pub use commit_v2::envelope::{MAX_GRAPH_DELTA_ENTRIES, MAX_GRAPH_IRI_LENGTH};
pub use commit_v2::format::{CommitSignature, ALGO_ED25519};
pub use commit_v2::verify_commit_v2_blob;
pub use error::{NoveltyError, Result};
pub use fluree_db_credential::SigningKey;
pub use stats::current_stats;

use fluree_db_core::{Flake, GraphId, IndexType, Sid};
use rayon::Scope;
use std::cmp::Ordering;
use std::collections::HashMap;

/// Index into FlakeStore - u32 limits to ~4B flakes
pub type FlakeId = u32;

/// Maximum FlakeId before overflow
pub const MAX_FLAKE_ID: u32 = u32::MAX - 1;

/// Arena-style storage for flakes
///
/// Flakes are stored once and referenced by FlakeId across all 4 indexes.
#[derive(Default, Clone)]
pub struct FlakeStore {
    /// The actual flakes
    flakes: Vec<Flake>,
    /// Per-flake size in bytes (for accurate size tracking)
    sizes: Vec<usize>,
}

impl FlakeStore {
    /// Create a new empty flake store
    pub fn new() -> Self {
        Self::default()
    }

    /// Get a flake by ID
    pub fn get(&self, id: FlakeId) -> &Flake {
        &self.flakes[id as usize]
    }

    /// Get the number of flakes stored
    pub fn len(&self) -> usize {
        self.flakes.len()
    }

    /// Check if the store is empty
    pub fn is_empty(&self) -> bool {
        self.flakes.is_empty()
    }

    /// Push a flake with a precomputed size (avoids double size_bytes)
    fn push_with_size(&mut self, flake: Flake, size: usize) -> FlakeId {
        let id = self.flakes.len() as FlakeId;
        self.sizes.push(size);
        self.flakes.push(flake);
        id
    }

    /// Test helper: push a flake (computes size).
    #[cfg(test)]
    fn push(&mut self, flake: Flake) -> FlakeId {
        let size = flake.size_bytes();
        self.push_with_size(flake, size)
    }

    /// Get the size of a flake by ID
    fn size(&self, id: FlakeId) -> usize {
        self.sizes[id as usize]
    }
}

/// Per-graph sorted index vectors.
///
/// Each graph gets its own set of 4 sorted FlakeId vectors (SPOT, PSOT, POST, OPST).
/// FlakeIds reference the shared `FlakeStore` arena.
#[derive(Clone, Default)]
struct GraphIndexVectors {
    spot: Vec<FlakeId>,
    psot: Vec<FlakeId>,
    post: Vec<FlakeId>,
    opst: Vec<FlakeId>,
}

impl GraphIndexVectors {
    fn get_index(&self, index: IndexType) -> &[FlakeId] {
        match index {
            IndexType::Spot => &self.spot,
            IndexType::Psot => &self.psot,
            IndexType::Post => &self.post,
            IndexType::Opst => &self.opst,
        }
    }

    /// Get slice of flake IDs for a leaf's range (binary search).
    fn slice_for_range(
        &self,
        store: &FlakeStore,
        index: IndexType,
        first: Option<&Flake>,
        rhs: Option<&Flake>,
        leftmost: bool,
    ) -> &[FlakeId] {
        let ids = self.get_index(index);

        if ids.is_empty() {
            return &[];
        }

        let start = if leftmost {
            0
        } else if let Some(f) = first {
            ids.partition_point(|&id| index.compare(store.get(id), f) != Ordering::Greater)
        } else {
            0
        };

        let end = if let Some(r) = rhs {
            ids.partition_point(|&id| index.compare(store.get(id), r) != Ordering::Greater)
        } else {
            ids.len()
        };

        if start >= end {
            return &[];
        }

        &ids[start..end]
    }

    /// Returns true if all index vectors are empty.
    fn is_empty(&self) -> bool {
        self.spot.is_empty() && self.psot.is_empty() && self.post.is_empty() && self.opst.is_empty()
    }

    /// Retain only alive flake IDs across all index vectors.
    fn retain_alive(&mut self, alive: &[bool]) {
        self.spot.retain(|&id| alive[id as usize]);
        self.psot.retain(|&id| alive[id as usize]);
        self.post.retain(|&id| alive[id as usize]);
        self.opst.retain(|&id| alive[id as usize]);
    }
}

/// Novelty overlay - in-memory storage for uncommitted transactions
///
/// Stores flakes in a shared arena with per-graph, per-index sorted vectors
/// for efficient range queries and merge operations.
///
/// GraphIds are dense small integers, so we use `Vec<Option<GraphIndexVectors>>`
/// indexed by `g_id as usize` instead of a HashMap.
#[derive(Clone, Default)]
pub struct Novelty {
    /// Canonical flake storage (arena), shared across all graphs
    store: FlakeStore,

    /// Per-graph sorted index vectors, indexed by g_id
    graphs: Vec<Option<GraphIndexVectors>>,

    /// Total size in bytes (for backpressure)
    pub size: usize,

    /// Latest transaction time in novelty
    pub t: i64,

    /// Epoch for cache invalidation - bumped once per commit
    pub epoch: u64,
}

impl Novelty {
    /// Create a new empty novelty overlay
    pub fn new(t: i64) -> Self {
        Self {
            store: FlakeStore::new(),
            graphs: Vec::new(),
            size: 0,
            t,
            epoch: 0,
        }
    }

    /// Ensure the graphs vec has a slot for `g_id`, growing if needed.
    fn ensure_graph(&mut self, g_id: GraphId) -> &mut GraphIndexVectors {
        let idx = g_id as usize;
        if idx >= self.graphs.len() {
            self.graphs.resize_with(idx + 1, || None);
        }
        self.graphs[idx].get_or_insert_with(GraphIndexVectors::default)
    }

    /// Resolve a flake's graph ID from its `Flake.g` field.
    ///
    /// - `None` → default graph (g_id = 0)
    /// - `Some(sid)` → looked up in `reverse_graph`; returns error if unknown
    fn resolve_flake_g_id(flake: &Flake, reverse_graph: &HashMap<Sid, GraphId>) -> Result<GraphId> {
        match &flake.g {
            None => Ok(0),
            Some(g_sid) => reverse_graph.get(g_sid).copied().ok_or_else(|| {
                NoveltyError::InvalidGraph(format!("flake references unknown graph Sid: {}", g_sid))
            }),
        }
    }

    /// Apply a batch of flakes from a commit, routing each flake to its graph.
    ///
    /// Epoch bumps ONCE per call, not per flake.
    /// Each flake is routed to its graph via `reverse_graph`. Unknown graph Sids
    /// cause an error — no silent fallback to the default graph.
    pub fn apply_commit(
        &mut self,
        flakes: Vec<Flake>,
        commit_t: i64,
        reverse_graph: &HashMap<Sid, GraphId>,
    ) -> Result<()> {
        if flakes.is_empty() {
            return Ok(());
        }

        let span = tracing::debug_span!(
            "novelty_apply_commit",
            commit_t = commit_t,
            flake_count = flakes.len(),
            rayon_threads = rayon::current_num_threads()
        );
        let _guard = span.enter();

        // Check FlakeId overflow
        let new_count = self.store.len() + flakes.len();
        if new_count > MAX_FLAKE_ID as usize {
            return Err(NoveltyError::overflow(
                "FlakeId overflow: too many flakes in novelty, trigger reindex",
            ));
        }

        // Update metadata
        self.t = self.t.max(commit_t);
        self.epoch += 1; // Bump epoch once per commit

        // Store flakes in arena, resolve graph IDs, and group by graph
        let mut per_graph: HashMap<GraphId, Vec<FlakeId>> = HashMap::new();

        for flake in flakes {
            let g_id = Self::resolve_flake_g_id(&flake, reverse_graph)?;
            let size = flake.size_bytes();
            self.size += size;
            let flake_id = self.store.push_with_size(flake, size);
            per_graph.entry(g_id).or_default().push(flake_id);
        }

        // Ensure all graph slots exist
        for &g_id in per_graph.keys() {
            self.ensure_graph(g_id);
        }

        // Merge each graph's batch into its 4 index vectors
        let store = &self.store;
        let parent = tracing::Span::current();

        for (g_id, batch_ids) in &per_graph {
            let graph_vecs = self.graphs[*g_id as usize]
                .as_mut()
                .expect("graph slot ensured above");
            let (spot, psot, post, opst) = (
                &mut graph_vecs.spot,
                &mut graph_vecs.psot,
                &mut graph_vecs.post,
                &mut graph_vecs.opst,
            );

            rayon::scope(|scope: &Scope<'_>| {
                let parent_spot = parent.clone();
                scope.spawn(move |_| {
                    let _p = parent_spot.enter();
                    merge_batch_into_index(store, spot, batch_ids, IndexType::Spot)
                });
                let parent_psot = parent.clone();
                scope.spawn(move |_| {
                    let _p = parent_psot.enter();
                    merge_batch_into_index(store, psot, batch_ids, IndexType::Psot)
                });
                let parent_post = parent.clone();
                scope.spawn(move |_| {
                    let _p = parent_post.enter();
                    merge_batch_into_index(store, post, batch_ids, IndexType::Post)
                });
                let parent_opst = parent.clone();
                scope.spawn(move |_| {
                    let _p = parent_opst.enter();
                    merge_batch_into_index(store, opst, batch_ids, IndexType::Opst)
                });
            });
        }

        Ok(())
    }

    /// Clear flakes with t <= cutoff_t (after index merge)
    ///
    /// Uses bitmap instead of HashSet for cache-friendly O(n) clear.
    ///
    /// Note: In the standard Fluree indexing flow, Novelty is replaced entirely
    /// after each index rebuild rather than mutated in-place. This method exists
    /// for completeness but is rarely needed.
    pub fn clear_up_to(&mut self, cutoff_t: i64) {
        let n = self.store.len();
        if n == 0 {
            return;
        }

        // Build alive bitmap and compute new size
        let mut alive = vec![false; n];
        let mut new_size = 0usize;

        for (i, is_alive) in alive.iter_mut().enumerate() {
            let flake = self.store.get(i as FlakeId);
            if flake.t > cutoff_t {
                *is_alive = true;
                new_size += self.store.size(i as FlakeId);
            }
        }

        // Retain only alive flakes in each graph's index vectors
        for slot in &mut self.graphs {
            if let Some(graph_vecs) = slot {
                graph_vecs.retain_alive(&alive);
                if graph_vecs.is_empty() {
                    *slot = None;
                }
            }
        }

        // Update size
        self.size = new_size;

        self.epoch += 1;
    }

    /// Get slice of flake IDs for a specific graph's leaf range.
    ///
    /// Returns `&[]` if the graph has no novelty.
    ///
    /// Uses binary search for O(log n + k) slicing.
    ///
    /// Clojure semantics:
    /// - If leftmost=false: left boundary is EXCLUSIVE (> first)
    /// - If leftmost=true: no left boundary
    /// - rhs is INCLUSIVE when present
    pub fn slice_for_range(
        &self,
        g_id: GraphId,
        index: IndexType,
        first: Option<&Flake>,
        rhs: Option<&Flake>,
        leftmost: bool,
    ) -> &[FlakeId] {
        match self.graphs.get(g_id as usize).and_then(Option::as_ref) {
            Some(graph_vecs) => {
                graph_vecs.slice_for_range(&self.store, index, first, rhs, leftmost)
            }
            None => &[],
        }
    }

    /// Get flake reference by ID
    pub fn get_flake(&self, id: FlakeId) -> &Flake {
        self.store.get(id)
    }

    /// Get the number of flakes in novelty
    pub fn len(&self) -> usize {
        self.store.len()
    }

    /// Check if novelty is empty
    pub fn is_empty(&self) -> bool {
        self.store.is_empty()
    }

    /// Iterate over all flake IDs for a given index across ALL graphs.
    ///
    /// Used by stats collection which needs the full picture regardless of graph.
    pub fn iter_index(&self, index: IndexType) -> impl Iterator<Item = FlakeId> + '_ {
        self.graphs
            .iter()
            .filter_map(Option::as_ref)
            .flat_map(move |graph_vecs| graph_vecs.get_index(index).iter().copied())
    }
}

impl std::fmt::Debug for Novelty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Novelty")
            .field("flake_count", &self.store.len())
            .field(
                "graphs",
                &self.graphs.iter().filter(|s| s.is_some()).count(),
            )
            .field("size", &self.size)
            .field("t", &self.t)
            .field("epoch", &self.epoch)
            .finish()
    }
}

// === OverlayProvider implementation ===

use fluree_db_core::OverlayProvider;

impl OverlayProvider for Novelty {
    fn epoch(&self) -> u64 {
        self.epoch
    }

    fn for_each_overlay_flake(
        &self,
        g_id: GraphId,
        index: IndexType,
        first: Option<&Flake>,
        rhs: Option<&Flake>,
        leftmost: bool,
        to_t: i64,
        callback: &mut dyn FnMut(&Flake),
    ) {
        let slice = self.slice_for_range(g_id, index, first, rhs, leftmost);

        for &id in slice {
            let flake = self.get_flake(id);
            if flake.t <= to_t {
                callback(flake);
            }
        }
    }
}

// =============================================================================
// Parallel merge helpers (read-only store + disjoint mutable index vectors)
// =============================================================================

/// LSM-style merge: sort batch by index comparator, then merge with existing target.
fn merge_batch_into_index(
    store: &FlakeStore,
    target: &mut Vec<FlakeId>,
    batch_ids: &[FlakeId],
    index: IndexType,
) {
    use rayon::prelude::*;

    // Sort batch by this index's comparator
    let mut sorted_batch = batch_ids.to_vec();
    sorted_batch.par_sort_unstable_by(|&a, &b| index.compare(store.get(a), store.get(b)));

    // Two-way merge existing + batch
    let mut merged = Vec::with_capacity(target.len() + sorted_batch.len());
    let mut i = 0;
    let mut j = 0;

    while i < target.len() && j < sorted_batch.len() {
        let cmp = index.compare(store.get(target[i]), store.get(sorted_batch[j]));
        if cmp != Ordering::Greater {
            merged.push(target[i]);
            i += 1;
        } else {
            merged.push(sorted_batch[j]);
            j += 1;
        }
    }
    merged.extend_from_slice(&target[i..]);
    merged.extend_from_slice(&sorted_batch[j..]);

    *target = merged;
}

#[cfg(test)]
mod tests {
    use super::*;
    use fluree_db_core::{FlakeValue, Sid};

    /// Empty reverse_graph — all flakes go to default graph (g_id=0)
    fn no_graphs() -> HashMap<Sid, GraphId> {
        HashMap::new()
    }

    fn make_flake(s: u16, p: u16, o: i64, t: i64, op: bool) -> Flake {
        Flake::new(
            Sid::new(s, format!("s{}", s)),
            Sid::new(p, format!("p{}", p)),
            FlakeValue::Long(o),
            Sid::new(2, "long"),
            t,
            op,
            None,
        )
    }

    fn make_ref_flake(s: u16, p: u16, o_sid: u16, t: i64) -> Flake {
        Flake::new(
            Sid::new(s, format!("s{}", s)),
            Sid::new(p, format!("p{}", p)),
            FlakeValue::Ref(Sid::new(o_sid, format!("s{}", o_sid))),
            Sid::new(1, "id"), // $id datatype marks it as a ref
            t,
            true,
            None,
        )
    }

    /// Make a flake assigned to a named graph via its `g` field
    fn make_graph_flake(s: u16, p: u16, o: i64, t: i64, g_sid: Sid) -> Flake {
        let mut f = Flake::new(
            Sid::new(s, format!("s{}", s)),
            Sid::new(p, format!("p{}", p)),
            FlakeValue::Long(o),
            Sid::new(2, "long"),
            t,
            true,
            None,
        );
        f.g = Some(g_sid);
        f
    }

    #[test]
    fn test_novelty_new() {
        let novelty = Novelty::new(5);
        assert_eq!(novelty.t, 5);
        assert_eq!(novelty.epoch, 0);
        assert_eq!(novelty.size, 0);
        assert!(novelty.is_empty());
    }

    #[test]
    fn test_apply_commit_single() {
        let mut novelty = Novelty::new(0);

        let flakes = vec![
            make_flake(1, 1, 100, 1, true),
            make_flake(2, 1, 200, 1, true),
        ];

        novelty.apply_commit(flakes, 1, &no_graphs()).unwrap();

        assert_eq!(novelty.len(), 2);
        assert_eq!(novelty.t, 1);
        assert_eq!(novelty.epoch, 1); // Epoch bumped once
        assert!(novelty.size > 0);
    }

    #[test]
    fn test_apply_commit_multiple() {
        let mut novelty = Novelty::new(0);
        let rg = no_graphs();

        // First commit
        novelty
            .apply_commit(vec![make_flake(1, 1, 100, 1, true)], 1, &rg)
            .unwrap();
        assert_eq!(novelty.epoch, 1);

        // Second commit
        novelty
            .apply_commit(vec![make_flake(2, 1, 200, 2, true)], 2, &rg)
            .unwrap();
        assert_eq!(novelty.epoch, 2); // Epoch bumped once per commit

        assert_eq!(novelty.len(), 2);
        assert_eq!(novelty.t, 2);
    }

    #[test]
    fn test_apply_commit_empty() {
        let mut novelty = Novelty::new(0);
        novelty.apply_commit(vec![], 1, &no_graphs()).unwrap();

        // Empty commit should not bump epoch
        assert_eq!(novelty.epoch, 0);
    }

    #[test]
    fn test_spot_ordering() {
        let mut novelty = Novelty::new(0);

        // Add flakes with different subjects
        let flakes = vec![
            make_flake(3, 1, 100, 1, true),
            make_flake(1, 1, 100, 1, true),
            make_flake(2, 1, 100, 1, true),
        ];

        novelty.apply_commit(flakes, 1, &no_graphs()).unwrap();

        // SPOT should order by subject
        let spot_ids: Vec<FlakeId> = novelty.iter_index(IndexType::Spot).collect();
        assert_eq!(spot_ids.len(), 3);

        let s1 = novelty.get_flake(spot_ids[0]).s.namespace_code;
        let s2 = novelty.get_flake(spot_ids[1]).s.namespace_code;
        let s3 = novelty.get_flake(spot_ids[2]).s.namespace_code;

        assert!(s1 <= s2 && s2 <= s3);
    }

    #[test]
    fn test_psot_ordering() {
        let mut novelty = Novelty::new(0);

        // Add flakes with different predicates
        let flakes = vec![
            make_flake(1, 3, 100, 1, true),
            make_flake(1, 1, 100, 1, true),
            make_flake(1, 2, 100, 1, true),
        ];

        novelty.apply_commit(flakes, 1, &no_graphs()).unwrap();

        // PSOT should order by predicate first
        let psot_ids: Vec<FlakeId> = novelty.iter_index(IndexType::Psot).collect();
        assert_eq!(psot_ids.len(), 3);

        let p1 = novelty.get_flake(psot_ids[0]).p.namespace_code;
        let p2 = novelty.get_flake(psot_ids[1]).p.namespace_code;
        let p3 = novelty.get_flake(psot_ids[2]).p.namespace_code;

        assert!(p1 <= p2 && p2 <= p3);
    }

    #[test]
    fn test_opst_all_object_types() {
        let mut novelty = Novelty::new(0);

        // Add mixed flakes - refs and non-refs
        let flakes = vec![
            make_flake(1, 1, 100, 1, true), // not a ref (Long)
            make_ref_flake(2, 1, 10, 1),    // ref
            make_flake(3, 1, 200, 1, true), // not a ref (Long)
            make_ref_flake(4, 1, 5, 1),     // ref
        ];

        novelty.apply_commit(flakes, 1, &no_graphs()).unwrap();

        // OPST should contain ALL flakes, not just refs
        let opst_ids: Vec<FlakeId> = novelty.iter_index(IndexType::Opst).collect();
        assert_eq!(opst_ids.len(), 4);
    }

    #[test]
    fn test_slice_for_range_basic() {
        let mut novelty = Novelty::new(0);

        let flakes = vec![
            make_flake(1, 1, 100, 1, true),
            make_flake(2, 1, 100, 1, true),
            make_flake(3, 1, 100, 1, true),
            make_flake(4, 1, 100, 1, true),
            make_flake(5, 1, 100, 1, true),
        ];

        novelty.apply_commit(flakes, 1, &no_graphs()).unwrap();

        // Full range (leftmost, no rhs) — default graph
        let slice = novelty.slice_for_range(0, IndexType::Spot, None, None, true);
        assert_eq!(slice.len(), 5);

        // From subject 2 (exclusive) to end
        let first = make_flake(2, 1, 100, 1, true);
        let slice = novelty.slice_for_range(0, IndexType::Spot, Some(&first), None, false);
        // Should get subjects 3, 4, 5 (> 2)
        assert_eq!(slice.len(), 3);

        // Absent graph returns empty slice
        let slice = novelty.slice_for_range(99, IndexType::Spot, None, None, true);
        assert!(slice.is_empty());
    }

    #[test]
    fn test_slice_for_range_with_rhs() {
        let mut novelty = Novelty::new(0);

        let flakes = vec![
            make_flake(1, 1, 100, 1, true),
            make_flake(2, 1, 100, 1, true),
            make_flake(3, 1, 100, 1, true),
            make_flake(4, 1, 100, 1, true),
            make_flake(5, 1, 100, 1, true),
        ];

        novelty.apply_commit(flakes, 1, &no_graphs()).unwrap();

        // From leftmost to subject 3 (inclusive) — default graph
        let rhs = make_flake(3, 1, 100, 1, true);
        let slice = novelty.slice_for_range(0, IndexType::Spot, None, Some(&rhs), true);
        // Should get subjects 1, 2, 3 (<= 3)
        assert_eq!(slice.len(), 3);
    }

    #[test]
    fn test_clear_up_to() {
        let mut novelty = Novelty::new(0);
        let rg = no_graphs();

        // Add flakes at different times
        novelty
            .apply_commit(vec![make_flake(1, 1, 100, 1, true)], 1, &rg)
            .unwrap();
        novelty
            .apply_commit(vec![make_flake(2, 1, 100, 2, true)], 2, &rg)
            .unwrap();
        novelty
            .apply_commit(vec![make_flake(3, 1, 100, 3, true)], 3, &rg)
            .unwrap();

        let initial_size = novelty.size;
        let initial_epoch = novelty.epoch;

        // Clear up to t=1 (should remove flake at t=1)
        novelty.clear_up_to(1);

        // Should have 2 flakes in spot index (t=2 and t=3)
        let remaining: Vec<FlakeId> = novelty.iter_index(IndexType::Spot).collect();
        assert_eq!(remaining.len(), 2);

        // Size should be reduced
        assert!(novelty.size < initial_size);

        // Epoch should be bumped
        assert_eq!(novelty.epoch, initial_epoch + 1);
    }

    #[test]
    fn test_merge_preserves_order() {
        let mut novelty = Novelty::new(0);
        let rg = no_graphs();

        // First batch
        novelty
            .apply_commit(
                vec![
                    make_flake(1, 1, 100, 1, true),
                    make_flake(3, 1, 100, 1, true),
                    make_flake(5, 1, 100, 1, true),
                ],
                1,
                &rg,
            )
            .unwrap();

        // Second batch - interleaved subjects
        novelty
            .apply_commit(
                vec![
                    make_flake(2, 1, 100, 2, true),
                    make_flake(4, 1, 100, 2, true),
                ],
                2,
                &rg,
            )
            .unwrap();

        // Check SPOT ordering
        let spot_ids: Vec<FlakeId> = novelty.iter_index(IndexType::Spot).collect();
        assert_eq!(spot_ids.len(), 5);

        // Verify sorted order
        for i in 0..spot_ids.len() - 1 {
            let cmp = IndexType::Spot.compare(
                novelty.get_flake(spot_ids[i]),
                novelty.get_flake(spot_ids[i + 1]),
            );
            assert_ne!(
                cmp,
                Ordering::Greater,
                "SPOT index not sorted at position {}",
                i
            );
        }
    }

    #[test]
    fn test_per_graph_isolation() {
        let mut novelty = Novelty::new(0);

        // Set up: graph 2 mapped to Sid("g", "graph2")
        let g2_sid = Sid::new(100, "graph2");
        let mut rg = HashMap::new();
        rg.insert(g2_sid.clone(), 2u16);

        // Default graph flakes (flake.g = None)
        let default_flakes = vec![
            make_flake(1, 1, 100, 1, true),
            make_flake(2, 1, 200, 1, true),
        ];

        // Named graph flakes (flake.g = Some(g2_sid))
        let named_flakes = vec![
            make_graph_flake(10, 1, 300, 1, g2_sid.clone()),
            make_graph_flake(11, 1, 400, 1, g2_sid.clone()),
            make_graph_flake(12, 1, 500, 1, g2_sid.clone()),
        ];

        let mut all = default_flakes;
        all.extend(named_flakes);
        novelty.apply_commit(all, 1, &rg).unwrap();

        // Default graph (g_id=0) should have 2 flakes
        let g0_slice = novelty.slice_for_range(0, IndexType::Spot, None, None, true);
        assert_eq!(g0_slice.len(), 2);

        // Named graph (g_id=2) should have 3 flakes
        let g2_slice = novelty.slice_for_range(2, IndexType::Spot, None, None, true);
        assert_eq!(g2_slice.len(), 3);

        // Non-existent graph returns empty
        let g99_slice = novelty.slice_for_range(99, IndexType::Spot, None, None, true);
        assert!(g99_slice.is_empty());

        // iter_index returns ALL flakes across graphs
        let all_spot: Vec<FlakeId> = novelty.iter_index(IndexType::Spot).collect();
        assert_eq!(all_spot.len(), 5);
    }

    #[test]
    fn test_unknown_graph_sid_errors() {
        let mut novelty = Novelty::new(0);
        let rg = no_graphs(); // No named graphs registered

        // Flake with a graph Sid that isn't in reverse_graph
        let unknown_g = Sid::new(200, "unknown");
        let flakes = vec![make_graph_flake(1, 1, 100, 1, unknown_g)];

        let result = novelty.apply_commit(flakes, 1, &rg);
        assert!(result.is_err());
        let err_msg = result.unwrap_err().to_string();
        assert!(err_msg.contains("unknown graph Sid"), "got: {}", err_msg);
    }

    #[test]
    fn test_flake_store() {
        let mut store = FlakeStore::new();
        assert!(store.is_empty());

        let f1 = make_flake(1, 1, 100, 1, true);
        let id1 = store.push(f1);
        assert_eq!(id1, 0);
        assert_eq!(store.len(), 1);

        let f2 = make_flake(2, 1, 200, 1, true);
        let id2 = store.push(f2);
        assert_eq!(id2, 1);
        assert_eq!(store.len(), 2);

        assert_eq!(store.get(0).s.namespace_code, 1);
        assert_eq!(store.get(1).s.namespace_code, 2);
    }
}
