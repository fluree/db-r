//! Commit v2 reader: binary blob -> Commit / CommitEnvelope.
//!
//! No NamespaceRegistry needed â€” Sids are reconstructed directly from
//! (namespace_code, name) pairs stored in the binary format.
//!
//! The v2 reader produces CID-based types (`ContentId`, `CommitRef`, `IndexRef`).
//! String-based references in the v2 on-disk format are converted to `ContentId`
//! during decode.

use super::error::CommitV2Error;
use super::format::{
    decode_sig_block, CommitV2Footer, CommitV2Header, FLAG_HAS_COMMIT_SIG, FLAG_ZSTD, FOOTER_LEN,
    HASH_LEN, HEADER_LEN, MIN_COMMIT_LEN,
};
use super::op_codec::{decode_op, ReadDicts};
use super::string_dict::StringDict;
use crate::{Commit, CommitEnvelope};
use fluree_db_core::{ContentId, CODEC_FLUREE_COMMIT};
use sha2::{Digest, Sha256};

/// Read a v2 commit blob and return a full `Commit` (with flakes).
///
/// The commit's `id` is derived from the v2 blob hash (SHA-256 of
/// everything before the trailing hash). This CID uses `CODEC_FLUREE_COMMIT`
/// and matches the hash that was used to construct the storage address.
pub fn read_commit(bytes: &[u8]) -> Result<Commit, CommitV2Error> {
    let blob_len = bytes.len();

    // 1. Validate minimum size
    if blob_len < MIN_COMMIT_LEN {
        return Err(CommitV2Error::TooSmall {
            got: blob_len,
            min: MIN_COMMIT_LEN,
        });
    }

    // 2. Parse header
    let header = CommitV2Header::read_from(bytes)?;

    // 3. Determine hash offset (accounts for trailing signature block)
    let sig_block_len = header.sig_block_len as usize;
    let has_sig_block = header.flags & FLAG_HAS_COMMIT_SIG != 0 && sig_block_len > 0;

    let hash_offset = if has_sig_block {
        if blob_len < HEADER_LEN + HASH_LEN + sig_block_len {
            return Err(CommitV2Error::TooSmall {
                got: blob_len,
                min: HEADER_LEN + HASH_LEN + sig_block_len,
            });
        }
        blob_len - sig_block_len - HASH_LEN
    } else {
        blob_len - HASH_LEN
    };

    // 4. Verify hash: SHA-256(bytes[0..hash_offset]) == bytes[hash_offset..hash_offset+32]
    let actual_hash: [u8; 32] = {
        let _span = tracing::debug_span!("v2_read_verify_hash", blob_len).entered();
        let expected_hash: [u8; 32] = bytes[hash_offset..hash_offset + HASH_LEN]
            .try_into()
            .unwrap();
        let actual_hash: [u8; 32] = Sha256::digest(&bytes[..hash_offset]).into();
        if expected_hash != actual_hash {
            return Err(CommitV2Error::HashMismatch {
                expected: expected_hash,
                actual: actual_hash,
            });
        }
        actual_hash
    };

    // 5. Derive ContentId from the v2 hash
    let commit_id = ContentId::from_sha256_digest(CODEC_FLUREE_COMMIT, &actual_hash);

    // 6. Parse signature block (if present)
    let commit_signatures = if has_sig_block {
        let sig_block_start = hash_offset + HASH_LEN;
        let sig_block_data = &bytes[sig_block_start..sig_block_start + sig_block_len];
        decode_sig_block(sig_block_data)?
    } else {
        Vec::new()
    };

    // 7. Decode binary envelope
    let envelope_start = HEADER_LEN;
    let envelope_end = envelope_start + header.envelope_len as usize;
    if envelope_end > blob_len {
        return Err(CommitV2Error::TooSmall {
            got: blob_len,
            min: envelope_end,
        });
    }
    let envelope = super::envelope::decode_envelope(&bytes[envelope_start..envelope_end])?;

    // 8. Parse footer
    let footer_start = hash_offset - FOOTER_LEN;
    let footer = CommitV2Footer::read_from(&bytes[footer_start..hash_offset])?;

    // 9. Validate ops section bounds
    let ops_start = envelope_end;
    let ops_end = ops_start + footer.ops_section_len as usize;
    if ops_end > footer_start {
        return Err(CommitV2Error::InvalidOp(
            "ops section extends into footer".into(),
        ));
    }

    // 10. Load dictionaries
    let dicts = load_dicts(bytes, &footer, ops_end, footer_start)?;
    let ops_bytes = &bytes[ops_start..ops_end];
    let ops_decompressed;
    let ops_data = if header.flags & FLAG_ZSTD != 0 {
        let _span = tracing::debug_span!("v2_read_decompress", compressed_bytes = ops_bytes.len())
            .entered();
        ops_decompressed =
            zstd::decode_all(ops_bytes).map_err(CommitV2Error::DecompressionFailed)?;
        tracing::debug!(
            compressed = ops_bytes.len(),
            decompressed = ops_decompressed.len(),
            "ops decompressed"
        );
        &ops_decompressed[..]
    } else {
        ops_bytes
    };

    // 11. Decode ops into flakes
    let flakes = {
        let _span = tracing::debug_span!(
            "v2_decode_ops",
            op_count = header.op_count,
            ops_bytes = ops_data.len()
        )
        .entered();
        let mut flakes = Vec::with_capacity(header.op_count as usize);
        let mut pos = 0;
        for _ in 0..header.op_count {
            let flake = decode_op(ops_data, &mut pos, &dicts, header.t)?;
            flakes.push(flake);
        }
        flakes
    };

    tracing::debug!(
        blob_len,
        op_count = header.op_count,
        t = header.t,
        compressed = (header.flags & FLAG_ZSTD != 0),
        "v2 commit read"
    );

    // 12. Assemble Commit with CID-based types
    Ok(Commit {
        id: Some(commit_id),
        t: header.t,
        time: envelope.time,
        flakes,
        previous_ref: envelope.previous_ref,
        index: envelope.index,
        txn: envelope.txn,
        namespace_delta: envelope.namespace_delta,
        txn_signature: envelope.txn_signature,
        commit_signatures,
        txn_meta: envelope.txn_meta,
        graph_delta: envelope.graph_delta,
    })
}

/// Read only the envelope from a v2 commit blob (no flakes, no hash check).
///
/// This is fast because it only reads the header + binary envelope section,
/// skipping the ops, dictionaries, and footer entirely.
pub fn read_commit_envelope(bytes: &[u8]) -> Result<CommitEnvelope, CommitV2Error> {
    // 1. Validate minimum size for header
    if bytes.len() < HEADER_LEN {
        return Err(CommitV2Error::TooSmall {
            got: bytes.len(),
            min: HEADER_LEN,
        });
    }

    // 2. Parse header
    let header = CommitV2Header::read_from(bytes)?;

    // 3. Decode binary envelope
    let envelope_start = HEADER_LEN;
    let envelope_end = envelope_start + header.envelope_len as usize;
    if envelope_end > bytes.len() {
        return Err(CommitV2Error::TooSmall {
            got: bytes.len(),
            min: envelope_end,
        });
    }
    let env = super::envelope::decode_envelope(&bytes[envelope_start..envelope_end])?;

    Ok(CommitEnvelope {
        t: header.t,
        previous_ref: env.previous_ref,
        index: env.index,
        namespace_delta: env.namespace_delta,
        txn_meta: env.txn_meta,
    })
}

/// Load and deserialize the 5 string dictionaries from the blob.
///
/// Validates that each dictionary is within `[valid_start..valid_end)` (the region
/// between the ops section and footer) and that dictionaries don't overlap.
pub(crate) fn load_dicts(
    bytes: &[u8],
    footer: &CommitV2Footer,
    valid_start: usize,
    valid_end: usize,
) -> Result<ReadDicts, CommitV2Error> {
    let dict_names = ["graph", "subject", "predicate", "datatype", "object_ref"];
    let mut prev_end = valid_start;

    let load_one = |loc: &super::format::DictLocation,
                    name: &str,
                    prev_end: &mut usize|
     -> Result<StringDict, CommitV2Error> {
        let start = loc.offset as usize;
        let end = start + loc.len as usize;
        if start < *prev_end {
            return Err(CommitV2Error::InvalidDictionary(format!(
                "{} dict at offset {} overlaps previous region ending at {}",
                name, start, *prev_end
            )));
        }
        if end > valid_end {
            return Err(CommitV2Error::InvalidDictionary(format!(
                "{} dict at offset {} len {} extends past dict region end {}",
                name, start, loc.len, valid_end
            )));
        }
        *prev_end = end;
        StringDict::deserialize(&bytes[start..end])
    };

    Ok(ReadDicts {
        graph: load_one(&footer.dicts[0], dict_names[0], &mut prev_end)?,
        subject: load_one(&footer.dicts[1], dict_names[1], &mut prev_end)?,
        predicate: load_one(&footer.dicts[2], dict_names[2], &mut prev_end)?,
        datatype: load_one(&footer.dicts[3], dict_names[3], &mut prev_end)?,
        object_ref: load_one(&footer.dicts[4], dict_names[4], &mut prev_end)?,
    })
}
