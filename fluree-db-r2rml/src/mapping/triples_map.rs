//! R2RML TriplesMap structure
//!
//! A TriplesMap is the top-level mapping unit in R2RML, defining how
//! rows from a logical table are transformed into RDF triples.

use serde::{Deserialize, Serialize};

use super::{PredicateObjectMap, TermType};

/// A compiled R2RML TriplesMap
///
/// A TriplesMap defines:
/// 1. A logical table (source of tabular data)
/// 2. A subject map (how to generate subject IRIs/blank nodes)
/// 3. Zero or more predicate-object maps (properties to generate)
///
/// # Example R2RML
///
/// ```turtle
/// <#AirlineMapping> a rr:TriplesMap ;
///     rr:logicalTable [ rr:tableName "openflights.airlines" ] ;
///     rr:subjectMap [
///         rr:template "http://example.org/airline/{id}" ;
///         rr:class ex:Airline
///     ] ;
///     rr:predicateObjectMap [
///         rr:predicate ex:name ;
///         rr:objectMap [ rr:column "name" ]
///     ] .
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TriplesMap {
    /// IRI identifying this TriplesMap in the mapping document
    pub iri: String,
    /// Logical table source
    pub logical_table: LogicalTable,
    /// Subject map (generates subject IRIs/blank nodes)
    pub subject_map: SubjectMap,
    /// Zero or more predicate-object maps
    pub predicate_object_maps: Vec<PredicateObjectMap>,
}

impl TriplesMap {
    /// Create a new TriplesMap with the given IRI and table name
    pub fn new(iri: impl Into<String>, table_name: impl Into<String>) -> Self {
        Self {
            iri: iri.into(),
            logical_table: LogicalTable::TableName(table_name.into()),
            subject_map: SubjectMap::default(),
            predicate_object_maps: Vec::new(),
        }
    }

    /// Set the subject map template
    pub fn with_subject_template(mut self, template: impl Into<String>) -> Self {
        self.subject_map.template = Some(template.into());
        self
    }

    /// Add a class to the subject map
    pub fn with_class(mut self, class_iri: impl Into<String>) -> Self {
        self.subject_map.classes.push(class_iri.into());
        self
    }

    /// Add a predicate-object map
    pub fn with_predicate_object(mut self, pom: PredicateObjectMap) -> Self {
        self.predicate_object_maps.push(pom);
        self
    }

    /// Get the table name if this is a table-based logical table
    pub fn table_name(&self) -> Option<&str> {
        match &self.logical_table {
            LogicalTable::TableName(name) => Some(name),
        }
    }

    /// Get all columns referenced by this TriplesMap
    ///
    /// Includes columns from subject template and all object maps.
    pub fn referenced_columns(&self) -> Vec<&str> {
        let mut columns: Vec<&str> = Vec::new();

        // Subject template columns
        columns.extend(self.subject_map.template_columns.iter().map(|s| s.as_str()));

        // Predicate-object map columns
        for pom in &self.predicate_object_maps {
            columns.extend(pom.predicate_map.referenced_columns());
            columns.extend(pom.object_map.referenced_columns());
        }

        // Deduplicate
        columns.sort();
        columns.dedup();
        columns
    }

    /// Get classes generated by the subject map
    pub fn classes(&self) -> &[String] {
        &self.subject_map.classes
    }

    /// Find a predicate-object map by predicate IRI
    pub fn find_predicate_object_map(&self, predicate_iri: &str) -> Option<&PredicateObjectMap> {
        self.predicate_object_maps.iter().find(|pom| {
            pom.predicate_map.as_constant() == Some(predicate_iri)
        })
    }

    /// Get columns referenced for a specific predicate filter.
    ///
    /// When `predicate_filter` is `Some`, only returns columns needed for:
    /// - Subject generation (template columns)
    /// - The specific POM matching the predicate
    ///
    /// When `predicate_filter` is `None`, returns all referenced columns.
    ///
    /// This enables projection pushdown to reduce I/O by reading only
    /// the columns needed for the current query.
    pub fn columns_for_predicate(&self, predicate_filter: Option<&str>) -> Vec<&str> {
        let mut columns: Vec<&str> = Vec::new();

        // Subject template columns are always needed
        columns.extend(self.subject_map.template_columns.iter().map(|s| s.as_str()));

        // Also include subject column if using rr:column instead of template
        if let Some(ref col) = self.subject_map.column {
            columns.push(col.as_str());
        }

        match predicate_filter {
            Some(pred) => {
                // Only include columns from the matching POM
                if let Some(pom) = self.find_predicate_object_map(pred) {
                    columns.extend(pom.predicate_map.referenced_columns());
                    columns.extend(pom.object_map.referenced_columns());
                }
            }
            None => {
                // No filter - include all POM columns (fallback to original behavior)
                for pom in &self.predicate_object_maps {
                    columns.extend(pom.predicate_map.referenced_columns());
                    columns.extend(pom.object_map.referenced_columns());
                }
            }
        }

        // Deduplicate
        columns.sort();
        columns.dedup();
        columns
    }

    /// Get columns that must be non-null to produce triples for a pattern.
    ///
    /// This method returns the minimal set of columns where a NULL value would
    /// prevent any triple from being generated. Use this for safe NOT NULL
    /// filter pushdown.
    ///
    /// # Rules
    ///
    /// - **Subject columns are always required**: if subject can't be materialized,
    ///   no triples can be produced from that row.
    /// - **Object columns are only required for the specific POM**: when
    ///   `predicate_filter` is `Some`, include object/join columns for that predicate.
    ///   When `None`, we cannot safely push NOT NULL for any object columns.
    ///
    /// # Arguments
    ///
    /// * `predicate_filter` - If `Some`, include object columns for that predicate.
    ///   If `None`, only subject columns are returned (safe for any pattern).
    ///
    /// # Template NULL handling
    ///
    /// R2RML semantics: if ANY column in a template is NULL, the term is not
    /// produced. E.g., `http://ex.org/{a}/{b}` with `a=NULL, b="foo"` produces
    /// nothing (not `http://ex.org//foo`).
    pub fn required_not_null_columns(&self, predicate_filter: Option<&str>) -> Vec<&str> {
        let mut columns: Vec<&str> = Vec::new();

        // Subject columns are ALWAYS required - without a subject, no triples at all
        columns.extend(self.subject_map.template_columns.iter().map(|s| s.as_str()));
        if let Some(ref col) = self.subject_map.column {
            columns.push(col.as_str());
        }

        // Object/join columns only when we know the specific predicate
        if let Some(pred) = predicate_filter {
            if let Some(pom) = self.find_predicate_object_map(pred) {
                match &pom.object_map {
                    super::ObjectMap::Column { column, .. } => {
                        columns.push(column.as_str());
                    }
                    super::ObjectMap::Template { columns: tmpl_cols, .. } => {
                        columns.extend(tmpl_cols.iter().map(|s| s.as_str()));
                    }
                    super::ObjectMap::RefObjectMap(rom) => {
                        // Child join columns are required
                        columns.extend(rom.child_columns());
                    }
                    super::ObjectMap::Constant { .. } => {
                        // Constant objects don't require any columns
                    }
                }
            }
        }
        // When predicate_filter is None, we can't safely include object columns
        // because different POMs have different requirements

        // Deduplicate
        columns.sort();
        columns.dedup();
        columns
    }
}

/// Logical table source
///
/// Defines where the tabular data comes from.
/// For Iceberg VGs, only table names are supported (not SQL queries).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum LogicalTable {
    /// `rr:tableName` - direct table reference
    ///
    /// Table names are normalized to dot notation: "namespace.table"
    TableName(String),
    // Note: rr:sqlQuery is explicitly NOT supported for Iceberg VGs
}

impl LogicalTable {
    /// Create a table name logical table
    pub fn table(name: impl Into<String>) -> Self {
        LogicalTable::TableName(name.into())
    }

    /// Get the table name if this is a table-based logical table
    pub fn as_table_name(&self) -> Option<&str> {
        match self {
            LogicalTable::TableName(name) => Some(name),
        }
    }

    /// Normalize table name (convert `/` to `.` for Iceberg)
    pub fn normalize_table_name(name: &str) -> String {
        name.replace('/', ".")
    }
}

/// Subject map
///
/// Defines how subject IRIs or blank nodes are generated from table rows.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct SubjectMap {
    /// `rr:template` - Template for generating subject IRI
    ///
    /// Example: `"http://example.org/airline/{id}"`
    pub template: Option<String>,

    /// Column names referenced in the template
    ///
    /// Extracted from template placeholders like `{id}`, `{name}`
    pub template_columns: Vec<String>,

    /// `rr:constant` - Constant subject IRI (alternative to template)
    ///
    /// Used when all rows should have the same subject (rare)
    pub constant: Option<String>,

    /// `rr:column` - Column containing subject IRI (alternative to template)
    ///
    /// The column value is used directly as the subject IRI
    pub column: Option<String>,

    /// `rr:class` - RDF type(s) for generated subjects
    ///
    /// Generates `?s rdf:type <class>` triples for each class
    pub classes: Vec<String>,

    /// `rr:termType` - Term type (IRI or BlankNode)
    ///
    /// Default is IRI. BlankNode generates blank node subjects.
    pub term_type: TermType,
}

impl SubjectMap {
    /// Create a template-based subject map
    pub fn template(template: impl Into<String>) -> Self {
        let template_str = template.into();
        let columns = extract_template_columns(&template_str);
        Self {
            template: Some(template_str),
            template_columns: columns,
            ..Default::default()
        }
    }

    /// Create a constant subject map
    pub fn constant(iri: impl Into<String>) -> Self {
        Self {
            constant: Some(iri.into()),
            ..Default::default()
        }
    }

    /// Create a column-based subject map
    pub fn column(col: impl Into<String>) -> Self {
        Self {
            column: Some(col.into()),
            term_type: TermType::Iri,
            ..Default::default()
        }
    }

    /// Add a class
    pub fn with_class(mut self, class_iri: impl Into<String>) -> Self {
        self.classes.push(class_iri.into());
        self
    }

    /// Set term type to blank node
    pub fn as_blank_node(mut self) -> Self {
        self.term_type = TermType::BlankNode;
        self
    }

    /// Check if this subject map generates IRIs
    pub fn generates_iri(&self) -> bool {
        self.term_type.is_iri()
    }

    /// Check if this subject map generates blank nodes
    pub fn generates_blank_node(&self) -> bool {
        self.term_type.is_blank_node()
    }
}

/// Extract column names from a template string
///
/// Finds all `{column_name}` placeholders and returns the column names.
/// For example, `"http://example.org/{namespace}/{id}"` returns `["namespace", "id"]`.
pub fn extract_template_columns(template: &str) -> Vec<String> {
    use once_cell::sync::Lazy;
    use regex::Regex;

    static PLACEHOLDER_RE: Lazy<Regex> = Lazy::new(|| {
        Regex::new(r"\{([^}]+)\}").expect("valid regex")
    });

    PLACEHOLDER_RE
        .captures_iter(template)
        .map(|cap| cap[1].to_string())
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_extract_template_columns() {
        let cols = extract_template_columns("http://example.org/{id}");
        assert_eq!(cols, vec!["id"]);

        let cols = extract_template_columns("http://example.org/{namespace}/{id}");
        assert_eq!(cols, vec!["namespace", "id"]);

        let cols = extract_template_columns("no placeholders");
        assert!(cols.is_empty());

        let cols = extract_template_columns("{a}{b}{c}");
        assert_eq!(cols, vec!["a", "b", "c"]);
    }

    #[test]
    fn test_triples_map_new() {
        let tm = TriplesMap::new("<#AirlineMapping>", "openflights.airlines")
            .with_subject_template("http://example.org/airline/{id}")
            .with_class("http://example.org/Airline");

        assert_eq!(tm.iri, "<#AirlineMapping>");
        assert_eq!(tm.table_name(), Some("openflights.airlines"));
        assert_eq!(tm.subject_map.template, Some("http://example.org/airline/{id}".to_string()));
        assert_eq!(tm.subject_map.classes, vec!["http://example.org/Airline"]);
    }

    #[test]
    fn test_logical_table_normalize() {
        assert_eq!(
            LogicalTable::normalize_table_name("openflights/airlines"),
            "openflights.airlines"
        );
        assert_eq!(
            LogicalTable::normalize_table_name("openflights.airlines"),
            "openflights.airlines"
        );
    }

    #[test]
    fn test_subject_map_template() {
        let sm = SubjectMap::template("http://example.org/{namespace}/{id}");
        assert_eq!(sm.template, Some("http://example.org/{namespace}/{id}".to_string()));
        assert_eq!(sm.template_columns, vec!["namespace", "id"]);
    }

    #[test]
    fn test_referenced_columns() {
        use super::super::{ObjectMap, PredicateMap, PredicateObjectMap};

        let mut tm = TriplesMap::new("<#Test>", "test.table");
        tm.subject_map = SubjectMap::template("http://example.org/{id}");
        tm.predicate_object_maps = vec![
            PredicateObjectMap {
                predicate_map: PredicateMap::constant("http://example.org/name"),
                object_map: ObjectMap::column("name"),
            },
            PredicateObjectMap {
                predicate_map: PredicateMap::constant("http://example.org/code"),
                object_map: ObjectMap::column("code"),
            },
        ];

        let cols = tm.referenced_columns();
        assert_eq!(cols, vec!["code", "id", "name"]);
    }

    #[test]
    fn test_columns_for_predicate() {
        use super::super::{ObjectMap, PredicateMap, PredicateObjectMap};

        let mut tm = TriplesMap::new("<#Test>", "test.table");
        tm.subject_map = SubjectMap::template("http://example.org/{id}");
        tm.predicate_object_maps = vec![
            PredicateObjectMap {
                predicate_map: PredicateMap::constant("http://example.org/name"),
                object_map: ObjectMap::column("name"),
            },
            PredicateObjectMap {
                predicate_map: PredicateMap::constant("http://example.org/code"),
                object_map: ObjectMap::column("code"),
            },
            PredicateObjectMap {
                predicate_map: PredicateMap::constant("http://example.org/country"),
                object_map: ObjectMap::column("country"),
            },
        ];

        // No filter: all columns
        let cols = tm.columns_for_predicate(None);
        assert_eq!(cols, vec!["code", "country", "id", "name"]);

        // Filter to specific predicate: only subject + that predicate's columns
        let cols = tm.columns_for_predicate(Some("http://example.org/name"));
        assert_eq!(cols, vec!["id", "name"]);

        let cols = tm.columns_for_predicate(Some("http://example.org/code"));
        assert_eq!(cols, vec!["code", "id"]);

        // Non-existent predicate: only subject columns
        let cols = tm.columns_for_predicate(Some("http://example.org/nonexistent"));
        assert_eq!(cols, vec!["id"]);
    }

    #[test]
    fn test_required_not_null_columns() {
        use super::super::{ObjectMap, PredicateMap, PredicateObjectMap, RefObjectMap, JoinCondition};

        let mut tm = TriplesMap::new("<#Test>", "test.table");
        tm.subject_map = SubjectMap::template("http://example.org/{ns}/{id}");
        tm.predicate_object_maps = vec![
            PredicateObjectMap {
                predicate_map: PredicateMap::constant("http://example.org/name"),
                object_map: ObjectMap::column("name"),
            },
            PredicateObjectMap {
                predicate_map: PredicateMap::constant("http://example.org/label"),
                object_map: ObjectMap::template("label-{code}", vec!["code".to_string()]),
            },
            PredicateObjectMap {
                predicate_map: PredicateMap::constant("http://example.org/parent"),
                object_map: ObjectMap::RefObjectMap(RefObjectMap {
                    parent_triples_map: "<#Parent>".to_string(),
                    join_conditions: vec![
                        JoinCondition {
                            child_column: "parent_id".to_string(),
                            parent_column: "id".to_string(),
                        },
                    ],
                }),
            },
            PredicateObjectMap {
                predicate_map: PredicateMap::constant("http://example.org/type"),
                object_map: ObjectMap::constant_iri("http://example.org/Thing"),
            },
        ];

        // No filter: only subject columns (safe for any pattern)
        let cols = tm.required_not_null_columns(None);
        assert_eq!(cols, vec!["id", "ns"]);

        // Filter to column predicate: subject + that column
        let cols = tm.required_not_null_columns(Some("http://example.org/name"));
        assert_eq!(cols, vec!["id", "name", "ns"]);

        // Filter to template predicate: subject + template columns
        let cols = tm.required_not_null_columns(Some("http://example.org/label"));
        assert_eq!(cols, vec!["code", "id", "ns"]);

        // Filter to RefObjectMap predicate: subject + child join columns
        let cols = tm.required_not_null_columns(Some("http://example.org/parent"));
        assert_eq!(cols, vec!["id", "ns", "parent_id"]);

        // Filter to constant predicate: only subject columns (constant always produces)
        let cols = tm.required_not_null_columns(Some("http://example.org/type"));
        assert_eq!(cols, vec!["id", "ns"]);

        // Non-existent predicate: only subject columns
        let cols = tm.required_not_null_columns(Some("http://example.org/nonexistent"));
        assert_eq!(cols, vec!["id", "ns"]);
    }
}
