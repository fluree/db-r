//! Dictionary overlay for binary index queries.
//!
//! `DictOverlay` wraps a `BinaryIndexStore` and extends its dictionaries with
//! ephemeral entries for predicates, graphs, language tags, and numbig values
//! that are present in novelty but not yet in the persisted binary index.
//!
//! Subject and string dictionaries are delegated to `DictNovelty` (shared
//! across queries within a `LedgerState`). Predicates, graphs, languages,
//! datatypes, and numbig remain per-query ephemeral (low cardinality).
//!
//! # Usage
//!
//! ```ignore
//! let mut overlay = DictOverlay::new(store.clone(), dict_novelty.clone());
//! let s_id = overlay.assign_subject_id_from_sid(&sid)?;
//! let iri = overlay.resolve_subject_iri(s_id)?;
//! ```

use fluree_db_core::dict_novelty::DictNovelty;
use fluree_db_core::flake::FlakeMeta;
use fluree_db_core::sid::Sid;
use fluree_db_core::subject_id::SubjectId;
use fluree_db_core::value::FlakeValue;
use fluree_db_core::value_id::{ObjKind, ObjKey};
use fluree_db_core::ListIndex;
use fluree_db_indexer::run_index::BinaryIndexStore;
use std::collections::HashMap;
use std::io;
use std::sync::Arc;

/// Per-query dictionary overlay for the binary index.
///
/// Subject and string lookups are delegated to `DictNovelty` (populated during
/// commit, shared across queries). Predicates, graphs, languages, datatypes,
/// and numbig remain per-query ephemeral.
///
/// Forward lookups use watermark routing: IDs at or below the watermark are
/// guaranteed to be in the persisted tree; IDs above the watermark are novel
/// and resolved from `DictNovelty`.
pub struct DictOverlay {
    store: Arc<BinaryIndexStore>,
    dict_novelty: Arc<DictNovelty>,

    // -- Ephemeral predicate extensions (per-query, low cardinality) --
    ext_predicates: HashMap<String, u32>,
    ext_predicate_iris: Vec<String>,

    // -- Ephemeral graph extensions --
    ext_graphs: HashMap<String, u32>,
    ext_graph_iris: Vec<String>,

    // -- Ephemeral language tag extensions --
    ext_lang_tags: HashMap<String, u16>,
    ext_lang_tag_values: Vec<String>,

    // -- Ephemeral NumBig extensions (BigInt/Decimal overflow) --
    ext_numbig: Vec<FlakeValue>,
    ext_numbig_map: HashMap<String, u32>, // canonical string repr → handle

    // -- Ephemeral subject/string fallback (range provider path only) --
    //
    // These are populated ONLY when DictNovelty is uninitialized (e.g., the
    // BinaryRangeProvider fallback path where dict_novelty can't be shared
    // across commits). In the main binary scan path with properly threaded
    // DictNovelty, these remain empty.
    ext_subjects: HashMap<String, u64>,
    ext_subject_iris: Vec<String>,
    ext_strings: HashMap<String, u32>,
    ext_string_values: Vec<String>,
    base_s_count: u64,
    base_str_count: u32,

    // -- Base dictionary sizes (ephemeral IDs start here) --
    base_p_count: u32,
    base_g_count: u32,
    base_lang_count: u16,
    numbig_next_handle: u32,
}

/// Handles above this value are ephemeral NumBig entries from DictOverlay.
const EPHEMERAL_NUMBIG_BASE: u32 = 0x8000_0000;

impl DictOverlay {
    /// Create a new overlay wrapping the given store and DictNovelty.
    pub fn new(store: Arc<BinaryIndexStore>, dict_novelty: Arc<DictNovelty>) -> Self {
        let base_p_count = store.predicate_count();
        let base_g_count = store.graph_ids().len() as u32;
        let base_lang_count = store.language_tag_count();
        let base_s_count = store.subject_count() as u64;
        let base_str_count = store.string_count();

        Self {
            store,
            dict_novelty,
            ext_predicates: HashMap::new(),
            ext_predicate_iris: Vec::new(),
            ext_graphs: HashMap::new(),
            ext_graph_iris: Vec::new(),
            ext_lang_tags: HashMap::new(),
            ext_lang_tag_values: Vec::new(),
            ext_numbig: Vec::new(),
            ext_numbig_map: HashMap::new(),
            ext_subjects: HashMap::new(),
            ext_subject_iris: Vec::new(),
            ext_strings: HashMap::new(),
            ext_string_values: Vec::new(),
            base_s_count,
            base_str_count,
            base_p_count,
            base_g_count,
            base_lang_count,
            numbig_next_handle: EPHEMERAL_NUMBIG_BASE,
        }
    }

    /// Reference to the underlying store.
    pub fn store(&self) -> &BinaryIndexStore {
        &self.store
    }

    // ========================================================================
    // Subject dictionary (delegated to DictNovelty)
    // ========================================================================

    /// Look up or assign a subject ID for the given IRI.
    ///
    /// Tries: persisted reverse index (canonical) → DictNovelty → ephemeral
    /// fallback. Ephemeral fallback is only used when DictNovelty is
    /// uninitialized (range provider path).
    pub fn assign_subject_id(&mut self, iri: &str) -> io::Result<u64> {
        // 1. Persisted tree (canonical — must be first)
        if let Some(id) = self.store.find_subject_id(iri)? {
            return Ok(id);
        }
        // 2. DictNovelty
        if self.dict_novelty.is_initialized() {
            let sid = self.store.encode_iri(iri);
            if let Some(id) = self.dict_novelty.subjects.find_subject(sid.namespace_code, &sid.name) {
                return Ok(id);
            }
        }
        // 3. Ephemeral fallback (for range provider path)
        if let Some(&id) = self.ext_subjects.get(iri) {
            return Ok(id);
        }
        let id = self.base_s_count + self.ext_subject_iris.len() as u64;
        self.ext_subjects.insert(iri.to_string(), id);
        self.ext_subject_iris.push(iri.to_string());
        Ok(id)
    }

    /// Assign a subject ID from a Sid (avoids IRI construction).
    ///
    /// Uses `find_subject_id_by_parts` for the persisted lookup (skips
    /// prefix_trie decomposition since we already have ns_code + suffix).
    /// Falls back to ephemeral allocation when DictNovelty is uninitialized.
    pub fn assign_subject_id_from_sid(&mut self, sid: &Sid) -> io::Result<u64> {
        // 1. Persisted tree
        if let Some(id) = self.store.find_subject_id_by_parts(sid.namespace_code, &sid.name)? {
            return Ok(id);
        }
        // 2. DictNovelty (populated during commit — guaranteed hit for novelty subjects)
        if self.dict_novelty.is_initialized() {
            if let Some(id) = self.dict_novelty.subjects.find_subject(sid.namespace_code, &sid.name) {
                return Ok(id);
            }
        }
        // 3. Ephemeral fallback (for range provider path)
        let iri = self.store.sid_to_iri(sid);
        if let Some(&id) = self.ext_subjects.get(&iri) {
            return Ok(id);
        }
        let id = self.base_s_count + self.ext_subject_iris.len() as u64;
        self.ext_subjects.insert(iri.clone(), id);
        self.ext_subject_iris.push(iri);
        Ok(id)
    }

    /// Resolve a subject ID back to an IRI string.
    ///
    /// Uses watermark routing: `local_id <= watermark` → persisted tree,
    /// `local_id > watermark` → DictNovelty forward lookup.
    /// When DictNovelty is uninitialized, tries persisted tree then ephemeral.
    pub fn resolve_subject_iri(&self, id: u64) -> io::Result<String> {
        if !self.dict_novelty.is_initialized() {
            // Uninitialized: try persisted tree first (handles both sid64 and flat IDs)
            if let Ok(iri) = self.store.resolve_subject_iri(id) {
                return Ok(iri);
            }
            // Ephemeral fallback: flat IDs allocated starting from base_s_count
            if id >= self.base_s_count {
                let idx = (id - self.base_s_count) as usize;
                if let Some(iri) = self.ext_subject_iris.get(idx) {
                    return Ok(iri.clone());
                }
            }
            return Err(io::Error::new(
                io::ErrorKind::InvalidData, format!("s_id {} not found", id),
            ));
        }
        let sid64 = SubjectId::from_u64(id);
        let wm = self.dict_novelty.subjects.watermark_for_ns(sid64.ns_code());

        if sid64.local_id() <= wm {
            // Guaranteed persisted
            return self.store.resolve_subject_iri(id);
        }
        // Novel — DictNovelty forward
        if let Some((ns_code, suffix)) = self.dict_novelty.subjects.resolve_subject(id) {
            let prefix = self.store.namespace_prefix(ns_code)?;
            return Ok(format!("{}{}", prefix, suffix));
        }
        Err(io::Error::new(
            io::ErrorKind::InvalidData,
            format!("s_id {} not found in store or DictNovelty", id),
        ))
    }

    /// Resolve a subject ID back to a Sid (encodes IRI via namespace trie).
    pub fn resolve_subject_sid(&self, id: u64) -> io::Result<Sid> {
        let iri = self.resolve_subject_iri(id)?;
        Ok(self.store.encode_iri(&iri))
    }

    // ========================================================================
    // Predicate dictionary (per-query ephemeral)
    // ========================================================================

    /// Look up or assign a predicate ID for the given IRI.
    pub fn assign_predicate_id(&mut self, iri: &str) -> u32 {
        if let Some(id) = self.store.find_predicate_id(iri) {
            return id;
        }
        if let Some(&id) = self.ext_predicates.get(iri) {
            return id;
        }
        let id = self.base_p_count + self.ext_predicate_iris.len() as u32;
        self.ext_predicates.insert(iri.to_string(), id);
        self.ext_predicate_iris.push(iri.to_string());
        id
    }

    /// Assign a predicate ID from a Sid.
    pub fn assign_predicate_id_from_sid(&mut self, sid: &Sid) -> u32 {
        let iri = self.store.sid_to_iri(sid);
        self.assign_predicate_id(&iri)
    }

    /// Resolve a predicate ID back to an IRI.
    pub fn resolve_predicate_iri(&self, id: u32) -> Option<&str> {
        if id < self.base_p_count {
            self.store.resolve_predicate_iri(id)
        } else {
            let idx = (id - self.base_p_count) as usize;
            self.ext_predicate_iris.get(idx).map(|s| s.as_str())
        }
    }

    /// Resolve a predicate ID back to a Sid.
    pub fn resolve_predicate_sid(&self, id: u32) -> Option<Sid> {
        self.resolve_predicate_iri(id).map(|iri| self.store.encode_iri(iri))
    }

    // ========================================================================
    // String dictionary (delegated to DictNovelty)
    // ========================================================================

    /// Look up or assign a string dictionary ID.
    ///
    /// Tries: persisted tree → DictNovelty → ephemeral fallback.
    pub fn assign_string_id(&mut self, value: &str) -> io::Result<u32> {
        // 1. Persisted tree
        if let Some(id) = self.store.find_string_id(value)? {
            return Ok(id);
        }
        // 2. DictNovelty (populated during commit)
        if self.dict_novelty.is_initialized() {
            if let Some(id) = self.dict_novelty.strings.find_string(value) {
                return Ok(id);
            }
        }
        // 3. Ephemeral fallback (for range provider path)
        if let Some(&id) = self.ext_strings.get(value) {
            return Ok(id);
        }
        let id = self.base_str_count + self.ext_string_values.len() as u32;
        self.ext_strings.insert(value.to_string(), id);
        self.ext_string_values.push(value.to_string());
        Ok(id)
    }

    /// Resolve a string ID back to the original value.
    ///
    /// Uses watermark routing: `id <= watermark` → persisted tree,
    /// `id > watermark` → DictNovelty forward lookup.
    /// When DictNovelty is uninitialized, tries persisted tree then ephemeral.
    pub fn resolve_string_value(&self, id: u32) -> io::Result<String> {
        if !self.dict_novelty.is_initialized() {
            // Try persisted tree first
            if let Ok(val) = self.store.resolve_string_value(id) {
                return Ok(val);
            }
            // Ephemeral fallback
            if id >= self.base_str_count {
                let idx = (id - self.base_str_count) as usize;
                if let Some(val) = self.ext_string_values.get(idx) {
                    return Ok(val.clone());
                }
            }
            return Err(io::Error::new(
                io::ErrorKind::InvalidData, format!("str_id {} not found", id),
            ));
        }
        let wm = self.dict_novelty.strings.watermark();

        if id <= wm {
            return self.store.resolve_string_value(id);
        }
        // Novel — DictNovelty forward
        if let Some(value) = self.dict_novelty.strings.resolve_string(id) {
            return Ok(value.to_string());
        }
        Err(io::Error::new(
            io::ErrorKind::InvalidData,
            format!("str_id {} not found in store or DictNovelty", id),
        ))
    }

    // ========================================================================
    // Language tag dictionary (per-query ephemeral)
    // ========================================================================

    /// Look up or assign a language tag ID.
    pub fn assign_lang_id(&mut self, tag: &str) -> u16 {
        if let Some(id) = self.store.find_lang_id(tag) {
            return id;
        }
        if let Some(&id) = self.ext_lang_tags.get(tag) {
            return id;
        }
        // Language tag IDs are 1-based (0 = no language).
        let id = self.base_lang_count + 1 + self.ext_lang_tag_values.len() as u16;
        self.ext_lang_tags.insert(tag.to_string(), id);
        self.ext_lang_tag_values.push(tag.to_string());
        id
    }

    /// Resolve a language tag ID back to the tag string.
    ///
    /// IDs 1..=base_lang_count are persisted (delegate to store).
    /// IDs above that are ephemeral extensions.
    /// ID 0 means "no language tag".
    pub fn resolve_lang_tag(&self, id: u16) -> Option<&str> {
        if id == 0 {
            return None;
        }
        let ephemeral_start = self.base_lang_count + 1;
        if id < ephemeral_start {
            // Persisted: delegate to store's language_tags.resolve()
            // (store's resolve handles 1-based IDs internally)
            None // Store doesn't expose resolve on DictOverlay; callers
                 // should use store directly for persisted IDs.
                 // In practice, the decode path goes through store.decode_meta().
        } else {
            let idx = (id - ephemeral_start) as usize;
            self.ext_lang_tag_values.get(idx).map(|s| s.as_str())
        }
    }

    // ========================================================================
    // Datatype dictionary
    // ========================================================================

    /// Look up a datatype ID, or return a best-effort fallback.
    ///
    /// Datatypes are a small fixed set (XSD types + custom) that should always
    /// be present in the persisted index. If truly missing, returns dt_id 0
    /// (which maps to an empty Sid) rather than failing.
    pub fn assign_dt_id(&self, dt_sid: &Sid) -> u16 {
        self.store.find_dt_id(dt_sid).unwrap_or(0)
    }

    // ========================================================================
    // Graph dictionary (per-query ephemeral)
    // ========================================================================

    /// Look up or assign a graph ID.
    pub fn assign_graph_id(&mut self, iri: &str) -> u32 {
        if let Some(&id) = self.ext_graphs.get(iri) {
            return id;
        }
        let id = self.base_g_count + self.ext_graph_iris.len() as u32;
        self.ext_graphs.insert(iri.to_string(), id);
        self.ext_graph_iris.push(iri.to_string());
        id
    }

    /// Resolve a graph ID back to an IRI.
    pub fn resolve_graph_iri(&self, id: u32) -> Option<&str> {
        if id < self.base_g_count {
            None // Persisted graph IRIs not stored on BinaryIndexStore currently
        } else {
            let idx = (id - self.base_g_count) as usize;
            self.ext_graph_iris.get(idx).map(|s| s.as_str())
        }
    }

    // ========================================================================
    // NumBig (BigInt/Decimal overflow) extensions
    // ========================================================================

    /// Assign an ephemeral NumBig handle for a BigInt/Decimal value.
    ///
    /// First checks if this value already has an ephemeral handle (by canonical
    /// string representation). Returns `(ObjKind::NUM_BIG, handle)`.
    fn assign_numbig_handle(&mut self, val: &FlakeValue) -> (ObjKind, ObjKey) {
        let key = format!("{:?}", val); // canonical Debug repr for dedup
        if let Some(&handle) = self.ext_numbig_map.get(&key) {
            return (ObjKind::NUM_BIG, ObjKey::encode_u32_id(handle));
        }
        let handle = self.numbig_next_handle;
        self.numbig_next_handle += 1;
        self.ext_numbig_map.insert(key, handle);
        self.ext_numbig.push(val.clone());
        (ObjKind::NUM_BIG, ObjKey::encode_u32_id(handle))
    }

    /// Resolve an ephemeral NumBig handle back to a FlakeValue.
    pub fn resolve_numbig(&self, handle: u32) -> Option<&FlakeValue> {
        if handle >= EPHEMERAL_NUMBIG_BASE {
            let idx = (handle - EPHEMERAL_NUMBIG_BASE) as usize;
            self.ext_numbig.get(idx)
        } else {
            None // Not ephemeral; delegate to store's numbig arena
        }
    }

    // ========================================================================
    // Value encoding (FlakeValue → ObjKind/ObjKey)
    // ========================================================================

    /// Convert a FlakeValue to an (ObjKind, ObjKey) pair, allocating ephemeral
    /// dictionary entries as needed.
    ///
    /// Unlike `BinaryIndexStore::value_to_obj_pair()`, this never returns `None`
    /// for representable values.
    pub fn value_to_obj_pair(&mut self, val: &FlakeValue) -> io::Result<(ObjKind, ObjKey)> {
        match val {
            FlakeValue::Null => Ok((ObjKind::NULL, ObjKey::from_u64(0))),
            FlakeValue::Boolean(b) => Ok((ObjKind::BOOL, ObjKey::encode_bool(*b))),
            FlakeValue::Long(n) => Ok((ObjKind::NUM_INT, ObjKey::encode_i64(*n))),

            FlakeValue::Double(d) => {
                // Integer-valued doubles that fit i64 → NUM_INT
                if d.is_finite() && d.fract() == 0.0 {
                    let as_i64 = *d as i64;
                    if (as_i64 as f64) == *d {
                        return Ok((ObjKind::NUM_INT, ObjKey::encode_i64(as_i64)));
                    }
                }
                if d.is_finite() {
                    match ObjKey::encode_f64(*d) {
                        Ok(key) => Ok((ObjKind::NUM_F64, key)),
                        Err(_) => Ok((ObjKind::NULL, ObjKey::from_u64(0))),
                    }
                } else {
                    // NaN/Inf → NULL sentinel (can't represent in index)
                    Ok((ObjKind::NULL, ObjKey::from_u64(0)))
                }
            }

            FlakeValue::Ref(sid) => {
                let s_id = self.assign_subject_id_from_sid(sid)?;
                Ok((ObjKind::REF_ID, ObjKey::from_u64(s_id)))
            }

            FlakeValue::String(s) => {
                let str_id = self.assign_string_id(s)?;
                Ok((ObjKind::LEX_ID, ObjKey::encode_u32_id(str_id)))
            }

            // Note: language strings use FlakeValue::String for the value;
            // the lang tag is in FlakeMeta.lang and handled by assign_lang_id()
            // in the caller (translate_one_flake).

            FlakeValue::Date(d) => {
                let days = d.days_since_epoch();
                Ok((ObjKind::DATE, ObjKey::encode_date(days)))
            }

            FlakeValue::DateTime(dt) => {
                let micros = dt.epoch_micros();
                Ok((ObjKind::DATE_TIME, ObjKey::encode_datetime(micros)))
            }

            FlakeValue::Time(t) => {
                let micros = t.micros_since_midnight();
                Ok((ObjKind::TIME, ObjKey::encode_time(micros)))
            }

            FlakeValue::GYear(g) => {
                Ok((ObjKind::G_YEAR, ObjKey::encode_g_year(g.year())))
            }

            FlakeValue::GYearMonth(g) => {
                Ok((ObjKind::G_YEAR_MONTH, ObjKey::encode_g_year_month(g.year(), g.month())))
            }

            FlakeValue::GMonth(g) => {
                Ok((ObjKind::G_MONTH, ObjKey::encode_g_month(g.month())))
            }

            FlakeValue::GDay(g) => {
                Ok((ObjKind::G_DAY, ObjKey::encode_g_day(g.day())))
            }

            FlakeValue::GMonthDay(g) => {
                Ok((ObjKind::G_MONTH_DAY, ObjKey::encode_g_month_day(g.month(), g.day())))
            }

            FlakeValue::YearMonthDuration(d) => {
                Ok((ObjKind::YEAR_MONTH_DUR, ObjKey::encode_year_month_dur(d.months())))
            }

            FlakeValue::DayTimeDuration(d) => {
                Ok((ObjKind::DAY_TIME_DUR, ObjKey::encode_day_time_dur(d.micros())))
            }

            FlakeValue::Duration(_) => {
                // xsd:duration is not totally orderable. Store as NumBig
                // with ephemeral handle to preserve the value through the overlay.
                Ok(self.assign_numbig_handle(val))
            }

            FlakeValue::Json(s) => {
                let str_id = self.assign_string_id(s)?;
                Ok((ObjKind::JSON_ID, ObjKey::encode_u32_id(str_id)))
            }

            FlakeValue::BigInt(bi) => {
                use num_traits::ToPrimitive;
                if let Some(v) = bi.to_i64() {
                    return Ok((ObjKind::NUM_INT, ObjKey::encode_i64(v)));
                }
                Ok(self.assign_numbig_handle(val))
            }

            FlakeValue::Decimal(_) => {
                Ok(self.assign_numbig_handle(val))
            }

            FlakeValue::Vector(v) => {
                let repr = format!("{:?}", v);
                let str_id = self.assign_string_id(&repr)?;
                Ok((ObjKind::VECTOR_ID, ObjKey::encode_u32_id(str_id)))
            }

            FlakeValue::GeoPoint(bits) => {
                Ok((ObjKind::GEO_POINT, ObjKey::from_u64(bits.as_u64())))
            }
        }
    }

    // ========================================================================
    // Decode (ID → FlakeValue)
    // ========================================================================

    /// Decode a value from integer-ID space back to `FlakeValue`.
    ///
    /// Uses watermark routing for subject refs and string IDs:
    /// IDs above the watermark are novel (resolved from DictNovelty).
    /// IDs at or below the watermark are persisted (delegated to store).
    pub fn decode_value(&self, o_kind: u8, o_key: u64, p_id: u32) -> io::Result<FlakeValue> {
        let initialized = self.dict_novelty.is_initialized();

        // REF_ID — check for novel/ephemeral subject IDs
        if o_kind == ObjKind::REF_ID.as_u8() {
            let ref_id = o_key;
            let is_novel = if initialized {
                let sid64 = SubjectId::from_u64(ref_id);
                let wm = self.dict_novelty.subjects.watermark_for_ns(sid64.ns_code());
                let novel = sid64.local_id() > wm;
                novel
            } else {
                // Ephemeral IDs are flat sequential starting at base_s_count.
                // Persisted sid64 IDs have namespace codes in upper bits, making
                // them far larger than the ephemeral range. Only classify as
                // ephemeral if the ID falls exactly in [base_s_count, base_s_count + len).
                ref_id >= self.base_s_count
                    && (ref_id - self.base_s_count) < self.ext_subject_iris.len() as u64
            };
            if is_novel {
                let iri = self.resolve_subject_iri(ref_id)?;
                return Ok(FlakeValue::Ref(self.store.encode_iri(&iri)));
            }
        }
        // LEX_ID — check for novel/ephemeral string IDs
        if o_kind == ObjKind::LEX_ID.as_u8() {
            let str_id = o_key as u32;
            let is_novel = if initialized {
                str_id > self.dict_novelty.strings.watermark()
            } else {
                str_id >= self.base_str_count
                    && (str_id - self.base_str_count) < self.ext_string_values.len() as u32
            };
            if is_novel {
                let s = self.resolve_string_value(str_id)?;
                return Ok(FlakeValue::String(s));
            }
        }
        // JSON_ID — check for novel/ephemeral string IDs
        if o_kind == ObjKind::JSON_ID.as_u8() {
            let str_id = o_key as u32;
            let is_novel = if initialized {
                str_id > self.dict_novelty.strings.watermark()
            } else {
                str_id >= self.base_str_count
                    && (str_id - self.base_str_count) < self.ext_string_values.len() as u32
            };
            if is_novel {
                let s = self.resolve_string_value(str_id)?;
                return Ok(FlakeValue::Json(s));
            }
        }
        // NUM_BIG with ephemeral handle
        if o_kind == ObjKind::NUM_BIG.as_u8() {
            let handle = o_key as u32;
            if let Some(val) = self.resolve_numbig(handle) {
                return Ok(val.clone());
            }
        }
        // Delegate to store for all persisted entries
        self.store.decode_value(o_kind, o_key, p_id)
    }

    /// Decode a datatype ID back to a Sid.
    pub fn decode_dt_sid(&self, dt_id: u16) -> Sid {
        self.store
            .dt_sids()
            .get(dt_id as usize)
            .cloned()
            .unwrap_or_else(|| Sid::new(0, ""))
    }

    /// Decode lang_id and i_val into FlakeMeta.
    ///
    /// Handles both persisted lang_ids (delegated to store) and ephemeral
    /// lang_ids allocated by `assign_lang_id()`.
    pub fn decode_meta(&self, lang_id: u16, i_val: i32) -> Option<FlakeMeta> {
        let has_lang = lang_id != 0;
        let has_idx = i_val != ListIndex::none().as_i32();

        if !has_lang && !has_idx {
            return None;
        }

        let mut meta = FlakeMeta::new();
        if has_lang {
            let ephemeral_start = self.base_lang_count + 1;
            let tag = if lang_id < ephemeral_start {
                // Persisted lang_id — delegate to store
                self.store.decode_meta(lang_id, ListIndex::none().as_i32())
                    .and_then(|m| m.lang)
            } else {
                // Ephemeral lang_id
                let idx = (lang_id - ephemeral_start) as usize;
                self.ext_lang_tag_values.get(idx).cloned()
            };
            if let Some(tag) = tag {
                meta = FlakeMeta::with_lang(tag);
            }
        }
        if has_idx {
            meta.i = Some(i_val);
        }
        Some(meta)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // Integration tests require a BinaryIndexStore, which needs on-disk files.
    // Unit-level logic tests for ephemeral ID allocation:

    #[test]
    fn test_ephemeral_numbig_dedup() {
        // Verify that the same canonical representation gets the same handle
        let key_a = "BigInt(42)".to_string();
        let key_b = "BigInt(42)".to_string();
        let mut map: HashMap<String, u32> = HashMap::new();
        map.insert(key_a, EPHEMERAL_NUMBIG_BASE);
        assert_eq!(map.get(&key_b), Some(&EPHEMERAL_NUMBIG_BASE));
    }
}
