//! Proxy storage implementation for peer mode
//!
//! Fetches index data via the transaction server's `/v1/fluree/storage/block` endpoint
//! instead of direct storage access. This allows peers to operate without storage
//! credentials (no S3 access, no filesystem mount).
//!
//! ## Policy-Safe Reads
//!
//! Under `PolicyEnforced` mode (the only mode currently available via the storage
//! proxy), the server **always** returns decoded, policy-filtered flakes (FLKB format)
//! for leaf blocks — even if the client requests `application/octet-stream`. Raw FLI1
//! leaf bytes are never returned to end users.
//!
//! Both `read_bytes()` and `read_bytes_hint()` use flakes-first content negotiation:
//! they request `application/x-fluree-flakes` first, falling back to
//! `application/octet-stream` on 406 (for non-leaf blocks like commits and branches).
//!
//! This means callers always receive:
//! - **Leaf blocks**: FLKB-encoded policy-filtered flakes
//! - **Non-leaf blocks**: raw bytes (commits, branches, manifests, etc.)
//!
//! The `ReadHint` distinction is preserved for forward-compatibility: if a
//! `TrustedInternal` enforcement mode is added later, `AnyBytes` could return
//! raw FLI1 leaves while `PreferLeafFlakes` would still prefer FLKB.

use async_trait::async_trait;
use fluree_db_core::error::{Error as CoreError, Result};
use fluree_db_core::format_ledger_id;
use fluree_db_core::storage::ReadHint;
use fluree_db_core::{
    ContentAddressedWrite, ContentId, ContentKind, ContentWriteResult, StorageRead, StorageWrite,
    CODEC_FLUREE_COMMIT, CODEC_FLUREE_DICT_BLOB, CODEC_FLUREE_GARBAGE, CODEC_FLUREE_INDEX_BRANCH,
    CODEC_FLUREE_INDEX_LEAF, CODEC_FLUREE_INDEX_ROOT, CODEC_FLUREE_LEDGER_CONFIG, CODEC_FLUREE_TXN,
};
use reqwest::{Client, StatusCode};
use serde::Serialize;
use std::fmt::Debug;
use std::time::Duration;

/// Storage implementation that proxies reads through the transaction server
#[derive(Clone)]
pub struct ProxyStorage {
    client: Client,
    base_url: String,
    token: String,
}

impl Debug for ProxyStorage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ProxyStorage")
            .field("base_url", &self.base_url)
            .finish_non_exhaustive()
    }
}

/// Request body for the `/storage/block` endpoint.
///
/// Both fields are required. The `cid` and `ledger` are derived from
/// the storage address via [`cid_and_ledger_from_address()`].
#[derive(Debug, Serialize)]
struct BlockRequest {
    cid: String,
    ledger: String,
}

/// Try to derive a CID string and ledger alias from a Fluree address.
///
/// Parses the canonical `fluree:{method}://{alias_path}/{kind_dir}/{hash}.{ext}`
/// format produced by [`fluree_db_core::content_address()`].
///
/// Returns `(cid_string, ledger_alias)` on success, or `None` if the format
/// is unrecognized (in which case the caller should fall back to address-based).
fn cid_and_ledger_from_address(address: &str) -> Option<(String, String)> {
    // Strip `fluree:{method}://` prefix
    let rest = address.strip_prefix("fluree:")?;
    let sep_pos = rest.find("://")?;
    let path = &rest[sep_pos + 3..];

    let parts: Vec<&str> = path.split('/').collect();
    let n = parts.len();
    if n < 3 {
        return None;
    }

    // Extract hash hex from the filename stem (before extension)
    let filename = parts[n - 1];
    let (hash_hex, _ext) = filename.rsplit_once('.')?;

    // Determine the multicodec and where the alias ends based on directory structure.
    // These patterns match those generated by `content_path()` in fluree-db-core.
    let (codec, alias_end) = if n >= 2 && parts[n - 2] == "commit" {
        (CODEC_FLUREE_COMMIT, n - 2)
    } else if n >= 2 && parts[n - 2] == "txn" {
        (CODEC_FLUREE_TXN, n - 2)
    } else if n >= 2 && parts[n - 2] == "config" {
        (CODEC_FLUREE_LEDGER_CONFIG, n - 2)
    } else if n >= 3 && parts[n - 3] == "index" && parts[n - 2] == "roots" {
        (CODEC_FLUREE_INDEX_ROOT, n - 3)
    } else if n >= 3 && parts[n - 3] == "index" && parts[n - 2] == "garbage" {
        (CODEC_FLUREE_GARBAGE, n - 3)
    } else if n >= 4 && parts[n - 4] == "index" && parts[n - 3] == "objects" {
        match parts[n - 2] {
            "branches" => (CODEC_FLUREE_INDEX_BRANCH, n - 4),
            "leaves" => (CODEC_FLUREE_INDEX_LEAF, n - 4),
            "dicts" => (CODEC_FLUREE_DICT_BLOB, n - 4),
            _ => return None,
        }
    } else {
        return None;
    };

    // Need at least 2 segments for the alias (name + branch)
    if alias_end < 2 {
        return None;
    }

    // Reconstruct ledger ID: "mydb/main" → "mydb:main".
    // Standard ledger format is "name:branch" where the branch is the last
    // path segment of the ledger ID prefix.
    let branch = parts[alias_end - 1];
    let name = parts[..alias_end - 1].join("/");
    let ledger_id = format_ledger_id(&name, branch);

    // Build CID from codec + hex digest
    let cid = ContentId::from_hex_digest(codec, hash_hex)?;
    Some((cid.to_string(), ledger_id))
}

/// Internal result type for fetch operations
///
/// This avoids using CoreError for the 406 case, which is an internal
/// retry condition rather than a user-facing error.
enum FetchOutcome {
    /// Successfully fetched bytes
    Success(Vec<u8>),
    /// Server returned 406 Not Acceptable (format not available)
    NotAcceptable,
    /// Fetch failed with an error
    Error(CoreError),
}

impl ProxyStorage {
    /// Create a new proxy storage client
    ///
    /// # Arguments
    ///
    /// * `base_url` - Base URL of the transaction server (e.g., `https://tx.fluree.internal:8090`)
    /// * `token` - Bearer token for authentication (with `fluree.storage.*` claims)
    pub fn new(base_url: String, token: String) -> Self {
        let client = Client::builder()
            .timeout(Duration::from_secs(60)) // 1 minute for block reads
            .build()
            .expect("Failed to create proxy storage client");

        // Normalize base_url by trimming trailing slashes
        let base_url = base_url.trim_end_matches('/').to_string();

        Self {
            client,
            base_url,
            token,
        }
    }

    /// Build the storage block endpoint URL
    fn block_url(&self) -> String {
        format!("{}/v1/fluree/storage/block", self.base_url)
    }

    /// Fetch with flakes-first content negotiation
    ///
    /// Tries `application/x-fluree-flakes` first. If the server returns 406
    /// (format not available for this block type), falls back to raw bytes.
    async fn fetch_prefer_flakes(&self, address: &str) -> Result<Vec<u8>> {
        // Try flakes format first
        match self
            .fetch_with_accept(address, "application/x-fluree-flakes")
            .await
        {
            FetchOutcome::Success(bytes) => Ok(bytes),
            FetchOutcome::NotAcceptable => {
                // 406 = not a leaf or policy filtering not applicable
                // Fall back to raw bytes
                tracing::debug!(
                    address = %address,
                    "Flakes format not available, falling back to raw bytes"
                );
                match self
                    .fetch_with_accept(address, "application/octet-stream")
                    .await
                {
                    FetchOutcome::Success(bytes) => Ok(bytes),
                    FetchOutcome::NotAcceptable => {
                        // Should not happen for octet-stream, but handle anyway
                        Err(CoreError::storage(format!(
                            "Storage proxy: octet-stream also rejected for {}",
                            address
                        )))
                    }
                    FetchOutcome::Error(e) => Err(e),
                }
            }
            FetchOutcome::Error(e) => Err(e),
        }
    }

    /// Internal fetch with a specific Accept header
    ///
    /// Returns `FetchOutcome` to distinguish between success, 406, and errors
    /// without using string-based error detection.
    ///
    /// Derives CID+ledger from the address. Failure to parse is a hard error
    /// (all storage addresses in the system use the canonical format).
    async fn fetch_with_accept(&self, address: &str, accept: &str) -> FetchOutcome {
        let url = self.block_url();
        let (cid, ledger) = match cid_and_ledger_from_address(address) {
            Some(pair) => pair,
            None => {
                return FetchOutcome::Error(CoreError::storage(format!(
                    "Cannot derive CID from address: {}",
                    address
                )));
            }
        };
        let body = BlockRequest { cid, ledger };

        let response = match self
            .client
            .post(&url)
            .header("Authorization", format!("Bearer {}", self.token))
            .header("Accept", accept)
            .json(&body)
            .send()
            .await
        {
            Ok(r) => r,
            Err(e) => {
                let err = if e.is_timeout() {
                    CoreError::io(format!("Storage proxy timeout for {}: {}", address, e))
                } else if e.is_connect() {
                    CoreError::io(format!(
                        "Storage proxy connection failed for {}: {}",
                        address, e
                    ))
                } else {
                    CoreError::io(format!(
                        "Storage proxy request failed for {}: {}",
                        address, e
                    ))
                };
                return FetchOutcome::Error(err);
            }
        };

        let status = response.status();

        match status {
            StatusCode::OK => match response.bytes().await {
                Ok(bytes) => FetchOutcome::Success(bytes.to_vec()),
                Err(e) => FetchOutcome::Error(CoreError::io(format!(
                    "Failed to read response body for {}: {}",
                    address, e
                ))),
            },
            StatusCode::NOT_FOUND => FetchOutcome::Error(CoreError::not_found(address)),
            StatusCode::NOT_ACCEPTABLE => {
                // 406 - format not available, signal for retry with different Accept
                FetchOutcome::NotAcceptable
            }
            StatusCode::UNAUTHORIZED => FetchOutcome::Error(CoreError::storage(format!(
                "Storage proxy authentication failed for {}: check token validity",
                address
            ))),
            StatusCode::FORBIDDEN => {
                // Address not in token scope - treat as not found (no existence leak)
                FetchOutcome::Error(CoreError::not_found(address))
            }
            s if s.is_server_error() => FetchOutcome::Error(CoreError::io(format!(
                "Storage proxy server error for {}: {}",
                address, status
            ))),
            _ => FetchOutcome::Error(CoreError::storage(format!(
                "Storage proxy unexpected status {} for {}",
                status, address
            ))),
        }
    }
}

#[async_trait]
impl StorageRead for ProxyStorage {
    async fn read_bytes(&self, address: &str) -> Result<Vec<u8>> {
        // Under PolicyEnforced, leaf blocks always return FLKB (not raw FLI1).
        // Use flakes-first negotiation for deterministic behavior across block types:
        // - Leaves → FLKB (policy-filtered flakes)
        // - Non-leaves → raw bytes (via 406 fallback to octet-stream)
        self.fetch_prefer_flakes(address).await
    }

    async fn read_bytes_hint(&self, address: &str, hint: ReadHint) -> Result<Vec<u8>> {
        // Under PolicyEnforced, both AnyBytes and PreferLeafFlakes produce the same
        // result (flakes-first negotiation). The distinction is preserved for
        // forward-compatibility with TrustedInternal mode.
        match hint {
            ReadHint::AnyBytes => self.read_bytes(address).await,
            ReadHint::PreferLeafFlakes => self.fetch_prefer_flakes(address).await,
            // Future ReadHint variants fall back to default
            _ => self.read_bytes(address).await,
        }
    }

    async fn exists(&self, address: &str) -> Result<bool> {
        // In v1, implement exists as try-read
        // This is correct but slightly less efficient than a HEAD request
        // The server currently only supports POST for blocks anyway
        match self.read_bytes(address).await {
            Ok(_) => Ok(true),
            Err(CoreError::NotFound(_)) => Ok(false),
            Err(e) => Err(e),
        }
    }

    async fn list_prefix(&self, _prefix: &str) -> Result<Vec<String>> {
        // ProxyStorage is read-only and doesn't support listing
        Err(CoreError::storage(
            "ProxyStorage does not support list_prefix".to_string(),
        ))
    }
}

#[async_trait]
impl StorageWrite for ProxyStorage {
    async fn write_bytes(&self, _address: &str, _bytes: &[u8]) -> Result<()> {
        Err(CoreError::storage(
            "ProxyStorage is read-only (writes must go to the transaction server)".to_string(),
        ))
    }

    async fn delete(&self, _address: &str) -> Result<()> {
        Err(CoreError::storage(
            "ProxyStorage is read-only (deletes must go to the transaction server)".to_string(),
        ))
    }
}

#[async_trait]
impl ContentAddressedWrite for ProxyStorage {
    async fn content_write_bytes_with_hash(
        &self,
        _kind: ContentKind,
        _ledger_alias: &str,
        _content_hash_hex: &str,
        _bytes: &[u8],
    ) -> Result<ContentWriteResult> {
        Err(CoreError::storage(
            "ProxyStorage is read-only (writes must go to the transaction server)".to_string(),
        ))
    }

    async fn content_write_bytes(
        &self,
        _kind: ContentKind,
        _ledger_alias: &str,
        _bytes: &[u8],
    ) -> Result<ContentWriteResult> {
        Err(CoreError::storage(
            "ProxyStorage is read-only (writes must go to the transaction server)".to_string(),
        ))
    }
}

impl fluree_db_core::StorageMethod for ProxyStorage {
    fn storage_method(&self) -> &str {
        "proxy"
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use fluree_db_core::ContentKind;

    #[test]
    fn test_proxy_storage_debug() {
        let storage = ProxyStorage::new(
            "http://localhost:8090".to_string(),
            "test-token".to_string(),
        );
        let debug = format!("{:?}", storage);
        assert!(debug.contains("ProxyStorage"));
        assert!(debug.contains("localhost:8090"));
        // Token should NOT be in debug output
        assert!(!debug.contains("test-token"));
    }

    #[test]
    fn test_block_url() {
        let storage = ProxyStorage::new(
            "http://localhost:8090".to_string(),
            "test-token".to_string(),
        );
        assert_eq!(
            storage.block_url(),
            "http://localhost:8090/v1/fluree/storage/block"
        );
    }

    #[test]
    fn test_block_url_with_trailing_slash() {
        let storage = ProxyStorage::new(
            "http://localhost:8090/".to_string(),
            "test-token".to_string(),
        );
        // Should work but might have double slash - that's okay for URLs
        assert!(storage.block_url().contains("/v1/fluree/storage/block"));
    }

    // ========================================================================
    // cid_and_ledger_from_address tests
    // ========================================================================

    /// Round-trip helper: build an address via `content_address`, then verify
    /// `cid_and_ledger_from_address` recovers the correct CID and ledger.
    fn assert_roundtrip(kind: ContentKind, alias: &str, data: &[u8]) {
        let id = ContentId::new(kind, data);
        let address = fluree_db_core::content_address("file", kind, alias, &id.digest_hex());
        let (cid_str, ledger) =
            cid_and_ledger_from_address(&address).expect("should parse address");
        assert_eq!(cid_str, id.to_string(), "CID mismatch for {address}");
        assert_eq!(ledger, alias, "ledger mismatch for {address}");
    }

    #[test]
    fn test_parse_commit_address() {
        assert_roundtrip(ContentKind::Commit, "mydb:main", b"commit data");
    }

    #[test]
    fn test_parse_txn_address() {
        assert_roundtrip(ContentKind::Txn, "mydb:main", b"txn data");
    }

    #[test]
    fn test_parse_index_root_address() {
        assert_roundtrip(ContentKind::IndexRoot, "mydb:main", b"root data");
    }

    #[test]
    fn test_parse_index_branch_address() {
        assert_roundtrip(ContentKind::IndexBranch, "mydb:main", b"branch data");
    }

    #[test]
    fn test_parse_index_leaf_address() {
        assert_roundtrip(ContentKind::IndexLeaf, "mydb:main", b"leaf data");
    }

    #[test]
    fn test_parse_dict_blob_address() {
        use fluree_db_core::DictKind;
        assert_roundtrip(
            ContentKind::DictBlob {
                dict: DictKind::Graphs,
            },
            "mydb:main",
            b"dict data",
        );
    }

    #[test]
    fn test_parse_config_address() {
        assert_roundtrip(ContentKind::LedgerConfig, "mydb:main", b"config data");
    }

    #[test]
    fn test_parse_garbage_address() {
        assert_roundtrip(ContentKind::GarbageRecord, "mydb:main", b"gc data");
    }

    #[test]
    fn test_parse_address_with_s3_method() {
        let id = ContentId::new(ContentKind::Commit, b"s3 test");
        let address = fluree_db_core::content_address(
            "s3",
            ContentKind::Commit,
            "prod:main",
            &id.digest_hex(),
        );
        let (cid_str, ledger) =
            cid_and_ledger_from_address(&address).expect("should parse s3 address");
        assert_eq!(cid_str, id.to_string());
        assert_eq!(ledger, "prod:main");
    }

    #[test]
    fn test_parse_address_not_fluree() {
        assert!(cid_and_ledger_from_address("https://example.com/foo").is_none());
    }

    #[test]
    fn test_parse_address_too_short() {
        assert!(cid_and_ledger_from_address("fluree:file://a/b").is_none());
    }

    #[test]
    fn test_parse_address_unknown_kind_dir() {
        assert!(cid_and_ledger_from_address("fluree:file://mydb/main/unknown/abc.bin").is_none());
    }
}
